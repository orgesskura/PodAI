Speaker A: The following is a conversation with Travis Oliphant, one of the most impactful programmers and data scientists ever. He created Numpy Scipy and anaconda. Numpy formed the foundation of tensor based machine learning in Python. Scipy formed the foundation of scientific programming in Python. And Anaconda, specifically with Conda, made Python more accessible to a much larger audience. Travis life work across a large number of programming and entrepreneurial efforts has and will continue to have immeasurable impact on millions of lives by empowering scientists and engineers in big companies, small companies, and open source communities to take on difficult problems and solve them with the power of programming. Plus, he's a truly kind human being, which is something that, when combined with vision and ambition, makes for a great leader and a great person to chat with. To support this podcast, please check out our sponsors in the description. This is the Lex Friedman podcast, and here is my conversation with Travis Oliphant. What was the first computer program you've ever written? Do you remember?
Speaker B: Whoa, that's a good question. I think it was in fourth grade. Just a simple. A loop in basic.
Speaker A: Basic?
Speaker B: Basic, yeah. On an Atari 800. Atari 400, I think. Or maybe it was an Atari 800. It was a part of a class, and we just were just basic loops to print things out.
Speaker A: Did you use go to statements?
Speaker B: Yes. Yes, we use go to statements.
Speaker A: I remember in the early days, that's when I first realized there's, like, principles to programming. When I was told that don't use go to statements. Those are bad software engineering principles. Like, it goes against what great, beautiful code is, I was like, oh, okay, there's rules to this game.
Speaker B: I didn't see that until high school, when I took an AP computer science course, I did a lot of other kinds of just low programming and Ti. Finally, when I took an AP computer science course in Pascal.
Speaker A: Wow.
Speaker B: Yeah, it was Pascal. That's when I. Oh, there are these principles.
Speaker A: Not c or c. No, I didn't.
Speaker B: Take c until the next year. In college, I had a course in circumental, but I haven't done much in Pascal, just that AP computer science course.
Speaker A: Now. Sorry for the romanticized question, but when did you first fall in love with programming?
Speaker B: Oh, man, good question. I think, actually, when I was ten, my dad got us a Tymex Sinclair, and he was excited about the spreadsheet capability. But I made him get the basic, the add on so we could actually program in bAsic. And just being able to write instructions and have the computer do something. Then we got a ti 99, four a, when I was about twelve. And I would just, it had sprites and graphics and music. You could actually program it to do music. That's when I really sort of fell in love with programming.
Speaker A: So this is a full, like a real computer with like, with memory and storage processors or whatnot?
Speaker B: Yeah, the Timex. Yeah, the Timex. Sinclair was one of the very first. Cheap, cheap like, I think it was. Well, it was still expensive, but it was two k of memory. We got the 16k add on pack, but yeah, it had memory and you could program it, you had to, in order to store your programs, you had to attach a tape drive. Remember that old. The sound that would play when you converted the modem would convert digital bits to audio files set on a tape drive. Still remember that sound, but that was the storage.
Speaker A: And what was the programming language, do you remember?
Speaker B: It was basic.
Speaker A: It was basic.
Speaker B: And then they had a visicalc and so a little bit of spreadsheet programming in busycock, but mostly just some basic.
Speaker A: Do you remember what kind of things drew you to programming? Was it working with data? Was it video games?
Speaker B: Video games, math.
Speaker A: Mathy stuff.
Speaker B: Yeah, I've always loved math, and a lot of people think they don't like math, because I think when they're exposed to it early, they, it's about memory. You know, when you're exposed to math early, it's, you have a good short term memory. Members timetables and I do have a reasonably, I mean, not perfect, but a reasonably long, um, little short term memory buffer. And so I did great at times tables. Oh, I get a math, but I started to really like math, just the problem solving aspect. And so computing was problem solving applied, and so that's always kind of been the draw, kind of coupled with the mathematics.
Speaker A: Did you ever see the computer as like an extension of your mind, like something able to achieve?
Speaker B: Not till later. Okay, yeah, not then.
Speaker A: It's just like a little set of puzzles that you can play with and you can play with math puzzles and.
Speaker B: Yeah, it was too rudimentary early on. Like, it was sort of. Yeah, it was too. It was a lot of work to actually take a thought you'd have and actually get it implemented, and that's still work, but it's getting easier. And so, yeah, I would say that's definitely what's attracting me to Python is that that was more real. I could think in python. Speaking of foreign language, I only speak another language fluently besides English, which is Spanish. And I remember the day when I would dream in Spanish. And you start to think in that language, and then you actually. I do definitely believe that language limits or expands your thinking. There are some languages that actually lead you to certain thought processes.
Speaker A: Yeah. So I speak Russian fluently, and that's certainly a language that leads you down certain thoughts. Well, yeah, I mean, there's a. There's a history of the two world wars, right, of the. Of millions of people starving to death and years of death throughout his history, of suffering, of injustice, like this promise sold to the people, and then the. The carpet or whatever, swept from under theme. It's like broken promises. And all of that pain and melancholy is in the language. The sad songs, the sad, hopeful songs, the over romanticized, like I love you, I hate you. The sort of the swings between all the various spectrums of emotion. So that's all within the language, the way it's twisted, poached. There's a strong culture of rhyming poetry. So, like the bards, like the sink, there's a musicality to the language, too.
Speaker B: Did Dostoevsky write in Russian?
Speaker A: Yeah. So, like Dostoevsky, Tolstoy, all the.
Speaker B: Ones that I know about, which are translated, and I'm curious how the translations.
Speaker A: So Dostoevsky did not use the musicality of the language too much. So it actually translates pretty well because it's so philosophically dense that the story does a lot of the work, but there's a bunch of things that are untranslatable. Certainly, the poetry is not translatable. I actually have a few conversations coming up offline and also on this podcast with people who've translated Dostoevsky. And that's for people who worked, who work in this field. Know how difficult that is? Sometimes you can spend, you know, months thinking about a single sentence right in the context, like, because there's just the magic captured by that sentence. And how do you translate it just in the right way? Because those words can be really powerful. There's a famous line, beauty will save the world from Dostoevsky. There's so many ways to translate that. And you're right, the language gives you the tools with which to tell the story, but it also leads your mind down certain trajectories and paths to where, over time, as you think in that language, you become a different human being.
Speaker B: Yes. Yeah. That's a fascinating reality, I think that is. I know people have explored that, but it's just rediscovered.
Speaker A: Well, we live in our own, like, little pockets. Like, this is the sad thing is, I feel like, unfortunately, given time and getting older, I'll never know China, the chinese world, because I don't truly know the language. Same with Japanese. I don't truly know Japanese and Portuguese. And Brazil, that whole south american continent. Yeah, I'll go to Brazil and Argentina. But will I truly understand the people if I don't understand the language? It's sad, because I wonder how many geniuses we're missing because so much of the scientific world, so much of the technical world is in English, and so much of it might be lost because they just. We don't have the common language.
Speaker B: I completely agree. I'm very much in that vein of there's a lot of genius out there that we miss, and we're sort of fortunate when it bubbles up into something that we can understand or process, there's a lot we miss. So that's why I tend to lean towards really loving democratization or things that empower people or very resistant to authoritarian structures, fundamentally for that reason. Well, several reasons, but it just hurts us. We're worse off.
Speaker A: So, speaking of languages that empower you. So Python was the first language for me that I really enjoyed thinking in, as you said.
Speaker B: Sounds like you shared my experience, too.
Speaker A: So when did you first. Do you remember when you first kind of connected with Python? Maybe even fell in love with Python?
Speaker B: It's a good question. It was a process. It took about a year. I first encountered Python in 1997. I was a graduate student studying biomedical engineering at the Mayo clinic. I had previously, I'd been involved in taking information from satellites. I was an electrical engineering student, used to taking information and trying to get something out of it, doing some data processing to get information out of it. I'd done that in Matlab. I'd done that in Perl. I'd done that in scripting on a VMS. There's actually a Vax VMS system, and they had their own little scripting tools around Fortran, done a lot of that. As a graduate student, I was looking for something and encountered Python. And because Python had an array, it had two things that made me not filter it away because I was filtering a bunch of stuff. Yorick, I looked at Yorick, I looked at a few other languages that are out there at the time in 1997, but it had arrays. There's a library called Numeric that had just been written in 95, not too much earlier, by an MIT alum, Jim Huguenin. And I went back and read the mailing list to see the history of how it grew. And there was a very interesting. Fascinating to do that, actually, to see how this emergent cooperation, unstructured cooperation, happens in the open source world. That led to a lot of this collective programming, which is something maybe we might get into a little later.
Speaker A: But what that looks like, what gap did numeric fill?
Speaker B: Numeric fill the gap of having an array object.
Speaker A: So instead, there was no array object.
Speaker B: There was no array. There was a one dimensional byte concept, but there was no n dimensional, two, three, four dimensional tensor, they call it. Now, I'm still in the category that a tensor is another thing, and it's just an ND array, we should call it. But kind of lost that battle.
Speaker A: There's many battles in this world, some of which we win, some we lose.
Speaker B: That's exactly right. But it had no math to it, so numeric had math and a basic way to think and erase. So I was looking for that. And it had complex numbers, a lot of programming languages. And you can see it, because if you're just a computer scientist, you think complex number is just two floats, so people can build that on. But in practice, a complex number is one of the significant algebras that helps connect a lot of physical and mathematical ideas, particularly to FFT, for an electrical engineer. And it's a really important concept, and not having it means you have to develop it several times. And those times may not share an approach. One of the common things in programming, one of the things programming enables, is abstractions. But when you have shared abstractions, it's even better. It sort of gets to the level of language, of actually, we all think of this the same way, which is both powerful and dangerous. Right. Because powerful in that we now can quickly make bigger and higher level things on top of those abstractions. Dangerous because it also limits us as to the things we left, maybe left behind in producing that abstraction which is at the heart of programming today and actually building around the programming world. So I think it's a fascinating philosophical topic.
Speaker A: Yeah, it will continue for many years.
Speaker B: I think for many years, as we.
Speaker A: Build more and more and more abstractions.
Speaker B: Yes. I often think about we have a world that's built on these abstractions that, were they the only ones possible? Certainly not. But they led to. Now it's very hard to do it differently. There's an inertia that's very hard to push out, push away from. That has implications for things like the Julia language, which you have heard of, I'm sure. And I've met the creators, and I like Julia. It's a really cool language, but they've struggled to kind of against just the tide of this inertia of people using Python, and there's strategies to approach that, but nonetheless, it's a phenomenon, and sometimes. So I love complex numbers and I love to raise, looked at Python, and then I had the experience. I did some stuff in Python, and I was just doing my PhD, so I was out. My focus was on. I was actually doing a combination of MRI and ultrasound and looking at a phenomenon called elastography, which is you push waves into the body and observe those waves like you can actually measure them, and then you do mathematical inversion to see what the elasticity is. And so that's the problem I was solving, is how to do that with both ultrasound and MrI. I needed some tool to do that with. So he was starting to use Python in 97. In 98, I went back, looked at what I'd written, and realized I could still understand it, which is not the experience I'd had when doing Perl in 95. Right. I'd done the same thing, and then I looked back and I forgot what it was he was saying. Now I'm not saying it. So that may, hey, this may work. I like this. This is something I can retain without becoming an expert, per se. And so that led me to go, hmm, I'm going to push more into this. And then that 98 was kind of the, when I started to fall in love with Python.
Speaker A: I would say a few peculiar things about Python, so maybe compare it to Perl compared to some of the other languages. So there's no braces.
Speaker B: Yeah.
Speaker A: So space is used, indentation, I should say, is used as part of our language.
Speaker B: Yeah, right.
Speaker A: So did you. I mean, that's quite a leap. Were you comfortable with that leap, or were you just very open minded?
Speaker B: Good question. I was open minded, so I was cognizant of the concern. And it definitely has, it has specific challenges. Cut and pasting, for example, when you're cut and pasting code, and if your editors aren't supportive of that or you're putting into a terminal, and particularly in the past, when terminals didn't necessarily have the intelligence to manage it, now, now, ipython and Jupyter notebooks handle that just fine, so there's really no problem. But in the past, it created some challenges. Formatting challenges, also mixed tabs and spaces. If you're. If editors weren't, you weren't clear on what was happening, you would have these issues. So there were really concrete reasons about it that I heard and understood. I never really encountered a problem with it personally. Like, it was occasional annoyances but I really liked the fact that it didn't have all this extra characters. Right. That these extra characters didn't show up in my visual field when I was just trying to process understanding a snippet of code.
Speaker A: Yeah, there's a cleanness to it, but I mean, the idea is supposed to be that Pearl also has a cleanness to it because of the minimalism of, like, how many characters it takes to express a certain thing. So it's very compact. But what you realize with that compactness comes. There's a culture that prizes compactness. And so the code gets more and more compact and less and less readable to a point where it's like to be a good programmer. In Perl, you write code that's basically unreadable.
Speaker B: Right.
Speaker A: There's a culture.
Speaker B: Correct. And you're proud of it.
Speaker A: Yeah, you're proud of it.
Speaker B: Right, exactly. And it feels good, and it's really selective. It means you have to be an expert in Perl to understand it, whereas Python allowed you not to have to be an expert. You don't have to take all this brain energy. You could leverage what I say, you could leverage your english language center, which you're using all the time. I've wondered about other languages, particularly non latin based languages. Latin based languages with the characters are at least similar. I think people have an easier time, but I don't know what it's like to be a japanese or a chinese person trying to learn a different, different syntax. Like, what would computer programming look like in that? I haven't looked at that at all, but it certainly doesn't. Leveraging your chinese language center. I'm not sure Python or any programming language does that, but that was a big deal. The fact that it was accessible, I could be a scientist. What I really liked is many programming languages really demand a lot of you, and you can get a lot. You do a lot if you learn it, but Python enables you to do a lot without demanding a lot of you. There's nuance to that statement. It certainly was more accessible so more people could actually, as a scientist, as somebody or engineer who was trying to solve another problem besides point programming, I could still use this language and get things done and be happy about it. Now, I was also comfortable in c at that time.
Speaker A: And Matlab.
Speaker B: You did a little. I did a lot before that. Exactly. So I was comfortable in those three languages were really the tools I used during my studies and schooling. But to your point about language helping you think, one of the big things about Matlab and APL before it. I don't know if you remember APL.
Speaker A: Nope.
Speaker B: APL is actually the predecessor of array based programming, which I think is really an underappreciated. If I talk to people who are just steeped in computer programming, computer science, like most of the people that Microsoft has hired in the past, for example, Microsoft as a company generally did not understand array based programming. Culturally, they didn't understand it. So they kept missing the boat, kept missing the understanding of what this, what this was. They've gotten better. But there's still a whole culture of folks that doesn't. Programming. That's, yeah, you know, that's, that's systems programming or web programming or lists and maps and, you know, what about an n dimensional array? Oh yeah, that's just an implementation detail. Well, you can think that, but then actually, if you have that as a construct, you actually think differently. APL was the first language to understand that, and it was in the sixties. Right. The challenge of APL is APL had very dense, not only glyphs, like new characters, new glyphs, they even had a new keyboard because to produce those glyphs, this is back in the early days of computing when the QWERTY keyboard maybe wasn't as established, like, well, we could have a new keyboard, no big deal, but it was a big deal and it didn't catch on. And the language APL, very much like Perl as people would pride themselves on. How much could they write the game of life in 30 characters of APL? APL has characters that meand summation and they have adverbs. They would have adjectives and these things called adverbs, which are like methods, like reduction. Reduction. It would be an adverb on an ad operator, but using these tools you could construct. And then you start to think at that level. You think in n dimensions is something I like to say, and you start to think differently about data at that point. Now it really helps.
Speaker A: Yeah. Outside of programming, if you really internalize linear algebra as a course, I mean, it philosophically allows you to think of the world differently.
Speaker B: Yes.
Speaker A: It's almost like liberating. You don't have to, you don't have to think about the individual numbers in the n dimensional array. You can think of it as an object in itself, and all of a sudden this world can open up. You're saying Matlab and ApL were like the early sea. I don't know if many languages got that right ever.
Speaker B: No, no, no, they didn't even still, I would say, I mean, numpy is an inheritor of the traditions that I would say APLJ was another version. That was what it did, is not have the glyphs, just have short characters, but still a latin keyboard could type them and then numeric inherited from that. In terms of let's add arrays plus broadcasting plus methods reduction. Even some of the language, like rank, is a concept that was in python, and it's still in python for the number of dimensions that's different than, say, the rank of a matrix, which people think of as well. It came from that tradition. But numpy is a very pragmatic, practical tool. Numpy inherited from numeric, and we can get to where numpy came from, which is the current array, at least current as of 2015, 2017. Now there's a ton of them over the past two or three years. We can get into that, too.
Speaker A: So if we just sort of linger on. The early days of what was your favorite feature of Python? Do you remember? Like what? Yeah, it's so interesting to linger on. Like the what. What really makes you connect with a language? I'm not sure it's obvious to introspect that.
Speaker B: No, it isn't. And I've thought about that to some length. I'm not. I think definitely the fact that I could read it later, that I could use it productively without becoming an expert. And other languages I had to put more effort into.
Speaker A: That's like an empirical observation. Like, you're not analyzing any one aspect of the language. It just seems time after time, when you look back, it's somehow readable.
Speaker B: It's somehow readable. Then it was sort of, I could take executable English and translate it to Python more easily. Like, I didn't have to go. There was no translation layer. As an engineer or as a scientist, I could think about what I wanted to do. And then the syntax wasn't that far behind it. Yeah, right now there's some warts there still. It wasn't perfect. There's some areas where I'm like, it would be better if this were different or if this were different. Some of those things got added to the language, too. I was really grateful for some of the early pioneers in the Python ecosystem back, because Python got written in 91 is when the first version came out. But Guido was very open to users, and one of the sets of users were people like Jim Hugan and David Asher and Paul Dubois and Conrad Hinson. These were people that were on the main list, and they were just asking for things like, hey, we really should have complex numbers in this language. So let's, you know, there's a j, there's a one j, right? And they, in fact, they went, the engineering root of J is interesting. I don't think that's entirely favoring engineers. I think it's because I is so often used as the index of a for loop. I think that's actually why probably, right.
Speaker A: I mean, there's a pragmatic aspect, but.
Speaker B: The fact that complex numbers were there, I love that. The fact that I could write nd array constructs and that reduction was there. Very simple to write summations and broadcasting was there. I could do addition of whole arrays. So that was cool. Those are some things I loved about it.
Speaker A: I don't know what to start talking to you about because you've created so many incredible projects that basically changed the whole landscape of programming. But okay, let's start with. Let's go chronologically with Scipy. You created scipi over two decades ago now.
Speaker B: Yes. I love to talk about Sci-Fi. Sci-Fi was really my baby.
Speaker A: What is it? What was its goal? What is its goal? How does it work?
Speaker B: Yeah, fantastic. Scipy was effectively here. I'm using python to do stuff that I previously used Matlab to use. I was using numeric, which is an array library. That made a lot of it possible. But there's things that were missing. I didn't have an ordinary differential equation solver. I could just call. I didn't have integration. I wanted to integrate this function. Well, I don't have just a function function I can call to do that. These are things I remember being critical things that I was missing. Optimization. I just want to pass a function to an optimizer and have it tell me what the optimum value is. Those are things like, well, why don't we just write a library that adds these tools? And I started to post on the mailing list, and there previously been people have discussed, I remember Conrad Henson saying, wouldn't it be great if we had this optimizer library? Or David Ash would say this stuff. Ambitious. Ambitious. The wrong word. An eager and probably more time than sense. I was a poor graduate student. My wife thinks I'm working on my PhD, and I am but part of a PhD that I loved was the fact that it's exploratory. You're not just taking orders, fulfilling a list of things to do, you're trying to figure out what to do. And so I thought, well, I'm writing tools for my own use, and a PhD. I'll just start this project. And so in 99 98 was when I first started to write libraries for Python effectively. When I fell in love with python 98, I thought, oh, well, there's just a few things missing, like, oh, I need a reader to read dicom files. I was in medical imaging and dicom was a format that I want to be able to load that into python. Okay, how do I write a reader for that? So I wrote something called, it was an IO package. That was my very first extension module, which is c. So I wrote C code to extend python so that in Python I could write things more easily. That combination kind of hooked me. It was the idea that I could. Here's this powerful tool I can use as a scripting language and a high level language to think about, but that I can extend easily, easily in c easily for me, because I knew enough c. And then Guido had written a language. I mean, the hard part of extending Python was something called the way memory management works. And you have to reference counting. And so there's a tracking of reference counting you have to do manually, and if you don't, you have memory leaks. And so that's hard. Plus then c, it's much more, you have to put more effort into it. It's not just I have to now think about pointers and I have to think about stuff that is different. I have to kind of, you're like putting a new cartridge in your brain, like, okay, I'm thinking about MRI now. I'm thinking about programming, and they're distinct modules you end up having to think about. So it's harder. When I was just in python, I could just think about MRI and high level writing, but I could do that and I liked it. I found that to be enjoyable and fun. I ended up, oh, let me just add a bunch of stuff to python to do integration. The cool thing is the power of the Internet. Just looking around and I found, oh, there's this net lib, which has hundreds of Fortran routines that people had written in the sixties, in the seventies and the eighties in Fortran 77. Fortunately, it wasn't Fortran sixties, it had been ported to Fortran 77. And Fortran 77 is actually a really great language. Fortran 90 probably is my favorite Fortran because it's got complex numbers, got arrays, and it's pretty high level now. The problem with it is you'd never want to write a program in four Chan 90 or Fortran 77. But it's totally fine to write a subroutine in four Chan got a little off course when they tried to compete with C. But at the time I just want libraries that do something like oh, here's an order of such equation. Here's integration, here's runge Kuta integration, already done. I don't have to think about that algorithm and you could, but it's nice to have somebody who's already done one and tested it. I started this journey in 98. Really. If you look back at the manual list, there's this productive era of me writing an extension module to connect runge cut integration to Python and making an ordinary differential equation solver and then releasing that as a package called odpack. I think I called it then Quadpack and then I just made these packages. Eventually that became multipack because they were originally modular. You can install them separately. But a massive problem in Python was actually just getting your stuff installed at the time. Releasing software for me like today, people think, what does that mean? Well then it meant some poorly written web page. I had some bad web page up and I put a tarball, just a gzip tarball of source code. That was the release.
Speaker A: But okay, can we just stand that? Because that the community aspect of creating the package and sharing that. Yes, that's rare that to have to both at that time. So like the rare.
Speaker B: Yeah, it was pretty early.
Speaker A: Yeah, well not, not rare. Maybe you can correct me on this, but it seems like in the scientific community so many people, you were basically solving the problems you needed to solve, to process the particular application, the data that you need and to also have the mind that I'm going to make this usable for others. That's, I would say I was inspired.
Speaker B: I'd been inspired by Linux, been inspired by Linus Linux and him making his code available and I was starting to use Linux at the time and I went this is cool. So I'd kind of been previously primed that way. And generally I was into science because I like the sharing notion. I like the idea of hey, let's if collectively we build knowledge and share it, we can all be better off.
Speaker A: Okay, so you weren't energized by that idea.
Speaker B: So I was energized by the already.
Speaker A: Yeah, right.
Speaker B: And I can't deny that I was, I'm sort of a, had this very, I liked that part of science, that part of sharing. And then all of a sudden oh wait, here's something. And here's something I could do. And then I slowly over years learned how to share better so that you could actually engage more people faster. One of the key things was actually giving people a binary they could install. So that wasn't just your source code. Good luck.
Speaker A: Compile this and then it's compiled, ready to install.
Speaker B: In fact, a lot of the journey from 98, even through 2012, when I started anaconda was about that. It's really the key as to why a scientist with dreams of doing MRI research ended up starting a software company that installs software.
Speaker A: I work with a few folks now that don't program like on the creative side and the video side, the audio side. And because my whole life is running on scripts, I have to try to get them. I'm having all the task of teaching them how to do python enough to run the scripts. And so I've been actually facing this, whether it's on the condos, some with the task of how do I minimally explain basically to my mom how to write a python script. And it's an interesting challenge after it's a to do item for me to figure out like what is the minimal amount of information I have to teach. What are the tools you use that one, you enjoy it to your effective.
Speaker B: And they're related, different. Two related questions.
Speaker A: And then the debugging, like the iterative process of running the script to figure out what the error is, maybe even for some people to do the fix yourself. So do you compile it? Do you distribute, like, how do you distribute that code to them? And it's interesting because I think it's exactly what you're talking about. If you increase the circle empathy that the circle of people that are able to use your programs, you increase its like, effectiveness and its power. And so you have to think, you know, can I write scripts? Can I write programs that can be used by, by medical engineers, by all kinds of people that don't know programming and actually maybe plant the seed, have them catch the bug of programming so that they start on the journey. And that's a huge responsibility. And ultimately it has to do with the Amazon one click buy. Like how, how frictionless can you make the early steps?
Speaker B: Frictionless is actually really key to growing any community. Is every, any friction point. You're just going to lose. You're going to lose some people.
Speaker A: Yeah.
Speaker B: Right now, sometimes you may want to intentionally do that. If you're early enough on, you need, you know, a lot of help. You need people who have the skills. You might actually, it's helpful. You don't necessarily have too much, too many users as opposed to kind contributors. If you're early on anyway, there's Sci-Fi started in 98, but it really emerged as this collection of modules that I was just putting on the net. People were downloading. I think I got 100 users by the end of that year. But the fact that I got 100 users and more than that, people started to email me with fixes, that was actually intoxicating. Here I'm writing papers and I'm giving conferences. Yeah, good job. But mostly it was, you're viewed with, it's competitive, you publish a paper and people are like, oh, it wasn't my paper. I was starting to see that sense of academic life where it was so much. I thought there was a cooperative effort. But it sounds like we're here just to one up each other, right? And that's not true across the board, but a lot of that's there. But here in this world I was getting responses from people all over the world. I remember Piero Peterson in Estonia was one of the first people and he sent me back this makefile because the first thing it is, yeah, your build thing stinks. And here's a better makefile. Now it was a complex makefile, I think. I never understood that makefile actually, but it worked and it did a lot more. And so I thought, thanks, this is cool. And that was my first kind of engagement with community development. But the process was he sent me a patch file, I had to upload a new tarball. And I just found, I really loved that. And the style back then was, here's a mailing list. It wasn't as they certainly weren't the tools that are available today. It was very early on, but I really started. That's the whole year, I think I did about seven packages that year. And then by the end of the year I collected them into a thing called multipack. So 99, there was this thing called multipack. And that's when a high school student, no, he was a high school student at the time. Guy named Robert Kern took that package and made a windows installer. Then of course a massive increase of usage.
Speaker A: By the way, most of this development was under Linux.
Speaker B: Yes, it was on Linux. I was a Linux developer doing it on Unix box at the time. I was actually getting into, I had a new hard drive to some kernel programming to make the hard drive work, not programming but modification to the kernel so I could actually get a hard drive working. I love that aspect of it. I was also at school, I was building a cluster. I took Mac computers and you put yellow dog Linux on them at the Mayo Clinic, they had all these Macs that were older they were just getting rid of. I got permission to go grab them together. I put about 24 of them together in a cluster in a cabinet and put yellow dog Linux on them all. And I wrote a c program to do MRI simulation. That was what I was doing at the same time for my day job, so to speak. So I was loving the whole process. At the same time I was, oh, I need a ordinary differential equation. That's why ordinary differential equations were key was because that's the heart of a block equation for simulating MRI is a OD solver. And so that's. I actually did that. This happened at the same time. That's why kind of what you're working on and what you're interested in, they're coinciding. I was definitely scratching my own itch in terms of building stuff, which helped in the sense that I was using it for me. So at least I had one user, I had one person who was like, well, no, this is better. I like this interface better. I had the experience of Matlab to guide some of what those APIs might look like, but you're just doing yourself, you're building all this stuff. But with the Windows installer, it was the first time I realized, oh, yeah, the binary installer really helps people. That led to spending more time on that side of things. So around 2000, so I graduated my PhD in 2000, end of 2000, so, 99, doing a lot of work there. 98, doing a lot of work there. 99, kind of spending more time on my PhD, helping people use the tools, thinking about, what do I want to go from here? There was a company, there was a guy actually, Eric Jones and Travis Vaught. They were two friends who founded a company called Enthot. That's here in Austin, still here. And they. Eric contacted me at the time when I was a, I was a graduate student still, and he said, hey, why don't you come down? We want to build a company. We're thinking of a scientific company, and we want to take what you're doing and add it to some stuff that he'd done. He'd written some tools, and then Piero Peterson had done FTPi. Let's come together and build, pull this all together and call it Scipy. That's the origin of the Scipy brand. It came from multipack and a whole bunch of modules I'd written plus a few things from some other folks, and then pull together in a single installer. Scipy was really a distribution of Python masquerading as a library.
Speaker A: How did you think about Scipy in context of Python? In context of numeric?
Speaker B: We saw Scipy as a way to make an R and D environment for Python use. Python depended on numeric, so numeric was the array library we depended on, and then from there extend it with a bunch of modules that allowed for. At the time, the original vision of Sci-Fi was to have plotting was to have a repl environment and really a whole data environment that you could then install and get going with. And that was the thinking. It didn't really evolve that way. It sort of had a. For one, it's really hard to do massive scale projects with open source collectives. Actually. There's sort of an intrinsic cooperation limit as to which too many cooks in the kitchen. You can do amazing infrastructure work when it comes down to bringing it all together into a single deliverable that actually requires a little more product management. That is not, that doesn't really emerge from the same dynamic. So it struggled, it struggled to get almost too many voices. It's hard to have everybody agree. Consensus doesn't really work at that scale. You end up with politics with the same kind of things that's happened in large organizations trying to decide on what to do together. So consensus building was challenging at scale. As more people came in early on, it's fine because there's nobody there, so it works. But then as you get more successful, the more people use it, all of a sudden, oh, there's this scale at which this doesn't work anymore, and we have to come up with different approaches. So Sci-Fi came out officially in 2001, was the first release. Most of the time. I remember the days of getting that release ready. It was a Windows installer and there were bugs on how the Windows compiler handled complex numbers and you're chasing segmentation faults. It's a lot of work. There was a lot of effort, had nothing to do with my area of study. At the same time, I had just gotten an offer, so he wondered if I wanted to come down and help him start that company with his friend. And at the time I was like, I was intrigued, but I was square in a path, an academic path, and I just got an offer to go and teach at my alma mater. So I took that tenure track position. Then I started working on Sci-Fi as a professor too. Okay, so I left. I left the Mayo clinic, graduated, wrote my thesis using Sci-Fi, wrote, you know, there's images that were created. Now the plotting tool I used was something from Yorick actually, it was a plotting PLT. Plotting language that I used.
Speaker A: Yorick is a programming language.
Speaker B: It was a programming language. It had a plotting tool, dislin. It had integration to Dislin. I ended up using Dislin plus some of the plotting from Yoricken linked to. From Python. Anyway, it was a people don't plot that way now, but this is before, and Scipi was trying to add plotting. Right. It didn't have much success, really. The success of plotting came from John Hunter, who had a similar experience to my experience, my kind of maverick experience as a person just trying to get stuff done and kind of having more time than money maybe. Right.
Speaker A: And Jon Hunter created what?
Speaker B: Mapplotlib.
Speaker A: He's the creator of Matlab.
Speaker B: Yeah. So John Hunter was. He wasn't a student at the time, but he was an actor. He was working in Quant Field. And he said, we need better plotting. So he just went out and said, cool, I'll make a new project and we'll call it Matplotlib. And he released in 2001 about the same time that Scipi came out. And it was separate library, separate install, use numeric, scipy used numeric. And so Scipy 2001, we released Scipy and then nthot created a conference called Scipi, which brought people together to talk about the space. And that conference is still ongoing. It's one of the favorite conferences of a lot of people because it's. It's changed over the years. But early on, it was a collection of 50 people who care about scientists, mostly practicing scientists, who want to care about coding and doing it well and not using Matlab. I remember being driven by. I liked Matlab, but I didn't like the fact that. So I'm not opposed to proprietary software. I'm actually not an open source zealot. I love open source for what it brings, but I also see the role for proprietary software. But what I didn't like was the fact that I would develop code and publish it and then effectively telling somebody here to run my code, you have to have this proprietary software.
Speaker A: Right. And there's also culture around Matlab as much because I've talked to a few folks in Mathworks grids. Matlab, yeah, I mean, there's just a culture. They try really hard, but it just is this corporate IBM style culture. It's like, or whatever. I don't. Don't want to say negative things about IBM, whatever, but there's a.
Speaker B: No, it's really that connection. It's something I'm in the middle of right now. Is the business of open source. And how do you connect the ethos of cooperative development with the necessity of creating profits? Right now, today I'm still in the middle of that. That's actually the early days of me exploring this question because I was writing Sci-Fi as an aside, I also had, so I had three kids at the time. I have six kids now. Got married early, wanted a family. I had three kids. And I remember reading, I read Richard Stallman's post and I was a fan of Stallman. I would read his work. I liked this collective ideas he would have, certainly the ideas on IP law. I read a lot of his stuff. But then he said, okay, well, how do I make money with this? How do I make a living? How do I pay for my kids? All this stuff was in my mind. Young graduate student making no money, thinking, I gotta get a job. And he said, well, I think, just be like me and don't have kids. Right? That's just, don't, don't.
Speaker A: That's his take on this.
Speaker B: That was what he said in that moment, right? That's the thing I read. And I went, okay, this is a train I can't get on.
Speaker A: Yeah. There has to be a way to preserve the culture of open source and still be able to make sufficient money to feed your.
Speaker B: Yes, exactly. There's got to be. Well, so that actually led me to a study of economics because at the time I was ignorant and I really was. And I'm actually, I'm embarrassed for educational system that they could let me. And I was valedictorian in my high school class and I did super well in college. And like academically I did great. But the fact that I could do that and then be clueless about this key part of life, it led me to go, there's a problem. Like I should, I should have learned this in fifth grade. I should have learned this in 8th grade. Like everybody should come out with a basic knowledge of economics.
Speaker A: You're an interesting example because you've created tools that change the lives of probably millions of people. And the fact that you don't understand at the time of the creation of those tools, the basics economics of how, like to build up giant systems problem.
Speaker B: Yeah, it's a problem. And so during my PhD, at the same time, this is back in 98, 99, at the same time I was in a library, I was reading books on capitalism, I was reading books on Marxism, I was reading books on, you know, what is this thing? What does it mean? And I encountered basically what I encountered a set of writings from people that said they were the inheritors of Adam Smith. Read Adam Smith for the first time, right? Which is the wealth of nations. And kind of this notion of emergent, emergent societies, and realized, oh, there's this whole world out here of people. And the challenge with economics is also political, because economics, people, different parties running for office, they want their economic friends, they want their economists to back them up or to be their magicians. They're magicians in Pharaoh's court. The people that are say, hey, you should listen to me because I've got the expert who says this. And so it gets really muddled, right? But I was looking at, as a scientist going, what is this space? What does this mean? How do people, how does Paris get fed? What is money? How does it work? I found a lot of writings I really loved. I found some things that I really loved, and I learned from that. It was writings from people like von misses. He wrote a peer to paper in 1920 that still should be read more than it is. It was the economic calculation problem of the socialist Commonwealth. It was basically in response to the Bolshevik revolution in 1917. His basic argument was, it's not going to work to not have private property. You're not going to be able to come up with prices. The bureaucrats aren't going to be able to determine how to allocate resources without a price system. And a price system emerges from people making trades. And they can only make trades if they have authority over the thing they're trading. And that creates information flow that you just don't have. If you try to top down it, it's like, huh, that's a really good point.
Speaker A: Yeah. Prices have a signal that's used, and it's important to have that signal when you're trying to build a community of productive people like you would in a software engineering space.
Speaker B: Yeah. The prices are actually an important signaling mechanism, and that money is just a bartering tool. So this is the first time I've encountered any of this concept. Right. And the fact that, oh, this is actually really critical. Like it's so critical to our prosperity and that we're dangerously not learning about this, not teaching our children about this.
Speaker A: So you had the three kids and you had to make some.
Speaker B: Had to make some money, right? Had to figure it out. But I didn't really care. I mean, I was never, I've never been driven by money. Just need it to eat.
Speaker A: So what, how did that resolve itself in terms of side by.
Speaker B: So I would say it didn't really resolve itself. It sort of started a journey that I'm continuing on and I'm still on. I would say I don't think it resolved itself, but I will say I went in wide eyes, wide open, like, I knew that there were problems with know, giving stuff away and creating the market externalities that the fact that, yeah, people might use it and I might not get paid for it, and I'll have to figure something else out to get paid. Like, at least I can say I'm not bitter that a lot of people have used stuff that I've written and I haven't necessarily benefited economically from it. I've heard other people be bitter about that when they write or they talk like, oh, I should have got more value out of this. And I'm also, I want to create systems that let people like me who might have these desires to do things, let them benefit. So it actually creates more of the same.
Speaker A: Not to turn on your bitterness module, but there's some aspect, I wish there was mechanisms for me to reward whoever created Sci, PI and numpy because it brought so much joy to my life.
Speaker B: I appreciate that.
Speaker A: You know what I mean?
Speaker B: The tip dark notion was there. I appreciate that. And I think, but there should be.
Speaker A: A very frictionless mechanism.
Speaker B: I totally agree. I would love to talk about some of the ideas I have because I actually came across, I think I've come up with some interesting notions that could work, but they'll require anything that will work. Takes time to emerge. Things don't just turn overnight. That's definitely one thing I've also understood and learned is any fixes? That's why it's kind of funny. We often give credit to, oh, this president gets elected and oh, look how great things have done. And I saw that when I had a transition in a condo when a new CEO came in. And it's like the success that's happening, there's an inertia there.
Speaker A: And sometimes the decision you made like ten years before is the reason why the success is CEO.
Speaker B: Right, exactly. You're sort of just running around taking credit for stuff.
Speaker A: Credit assignment has like a delay to it that makes the credit assignment basically wrong more than right.
Speaker B: Wrong more than right. Exactly. And so I'm like, oh, this is, you know, that's the stuff I would read a ton about, you know, early on. So I don't, I feel like I'm with you. Like I want the same thing. I want to be able to. And honestly, not for personally, I've been happy. I've been happy I feel like I don't have any. I mean, we've been done reasonably okay, but I've had to pursue it. Like, that's really what started my trajectory from academia, is reading that stuff led me say, oh, entrepreneurship matters. I love software, but we need more entrepreneurs, and I want to understand that better. So once I kind of had that virus infect my brain, even though I was on a trajectory to go to a tenure track position at a university, and I was there for six years, I was kind of already out the door when I started. And we can get into that.
Speaker A: But can I just ask a quick question on is there some design principles that were in your mind around scipy? Was there some key ideas that were just sticking to you, that this is the fundamental ideas?
Speaker B: Yeah, I would say so. I would think it's basically accessibility to scientists. Give scientists and engineers tools that they don't have to think a lot about programming. So give them really good building blocks, give them functions that they want to call and sort of just the right length of spelling. You know, there's a one tradition in programming where it's like, make very, very long names, right? And you can see it in some programming languages where the names get tick half the screen. And in the four chan world, characters would have to be six letters early on. Right. And that's way too much, too little. But I was like, I liked to have names that were informative but short.
Speaker A: So even though Python. Well, this is a different conversation, but documentation is doing some work there. So when you look at great scientific libraries and functions, there's a richness of documentation that helps you get into the details. The first glance at a function gives you the intuition of all it needs to do by looking at the headers and so on. But to get the depths of all the complexities involved, all the options involved, documentation does.
Speaker B: Some of that is essential. Yeah. So that was actually. So we thought about several things. One is we wanted plotting, we wanted interactive environment, we wanted good documentation. These are things we knew we wanted. The reality is those took about ten years to evolve. Given the fact that we didn't have a big budget, it was all volunteer labor. It was sort of when n thought got created and they started to try to find projects, people would pay for pieces and they were able to fund some of it. Not nearly enough to keep up with what was necessary, and no criticism, just simply the reality. Hard to start a business and then do consulting and then also promote open source project that's still fairly new. Cyboy is fairly niche we stayed connected all while I was a student. Sorry, a professor. I went to BYU and started to teach electrical engineering, all the applied math courses. I loved teaching signal processing, probability theory, electromagnetism. I was, if you look at rate, my professor, which my kids love to do, I wasn't. I got some bad reviews because people.
Speaker A: What was the criticism?
Speaker B: I would speak too high of a level. Like, I definitely had a calibration problem coming out of graduate work, where I hate to be condescending to people. Like, I really have a ton of respect for people. Fundamentally. Like, my fundamental thing is I respect people. Sometimes that can lead to a. I was thinking they had more knowledge than they did, and so I would just speak at a very high level, assume they got it, but they need to.
Speaker A: Rise to the standard that you set. I mean, that's one of. Some of the greatest teachers do that.
Speaker B: And I agree. That was kind of what was inspiring me. But you also have to. I cannot say I was articulate as some of the greatest teachers. One classic example, when I first taught at BYU, my very first class, it was overheads. Transparency is overheads. Before projectors were really that common. So transparencies. I'm writing my notes out. I go in rooms half dark. I just blaring through these transparencies. Here it is. Here it is, here it is. And I gave a quiz. After two weeks, nowhere knew anything. Nothing. I got anywhere, and I realized, okay, this is not working. So I took, put away the transparencies, and I turned around, just started using the chalkboard. And what it did is it slowed me down. Right? The chalkboard just slowed me down and gave people time to process and to think. And then that made me focus. My writing wasn't great on the chalkboard, but I really love that part of, like, the teaching. So that that entered Sci PI's world in terms of, we always understood that there's a didactic aspect of scipi, kind of, how do you take the knowledge and then produce it? The challenge we had was the scope. Like, ultimately, scipy was everything, right? And so 2001, when it first came out, people were starting to use it. No, this is cool. This is a tool we actually use at the same time, 2001 timeframe. There was a little bit of the Hubble space telescope. The folks at Hubble had started saying, hey, python, we're going to use Python for processing images from Hubble. Perry Greenfield was a good friend and running that program, and he had called me before I left to BYU and said, you know, we want to do this, but numeric actually has some challenges in terms of, you know, it's not a. The array doesn't have enough types. We need more operations. You know, broadcast needs to be a little more settled. They wanted record arrays. They wanted, you know, record arrays are like a data frame, but a little bit different, but they wanted more structured data. So he had called me even early on then, and they said, wait, would you want to work on something to make this work? I said, yeah, I'm interested, but I'm going here. We'll see if I have time. So in the meantime, while I was teaching and Saipo was emerging, and I had a student, I was constantly, while I was teaching, trying to figure a way to fund this stuff. So I had a graduate student, my only graduate student, a chinese fellow, Liu Hong Ze is his name. Great guy. He wrote a bunch of stuff for iterative linear algebra, like, got into writing some of the iterative literary algebra tools that are currently there in scipy, and they've gotten better since. But this is in 2005. Kept working on ScI-Fi but Perry had started working on a replacement to numeric called Numare, and in 2004, a package called ndimage. It was an image processing library that was written for numeray, and it had in it a morphology tool. I don't even know what morphology is. It's open dilations. There was sort of this. As a medical imaging student, I knew what it was because it was used in segmentation a lot. And in fact, I wanted to do something like that in Python, in Sci-Fi but just had never gotten around to it. So when it came out that it worked only on numerai, and scipy needed numeric. And so we effectively had the beginning of this split, and numeric and numerator didn't share data. They were just two. So you could have a gigabyte of numerai data and gigabyte of numeric data, and they wouldn't share it. And so you had these, then you had these scientific libraries written on top. I got really bugged by that. I got really like, oh, man, this is not good. We're not cooperating now. We're sort of redoing each other's work, and we're just this young community. So that's what led me, even though I knew it was risky because I was on a tenure track position. 2004, I got reviewed. They said, hey, things are going okay. You're doing well. Paper's coming out, but you're kind of spending a lot of time on this open source stuff. Maybe do a little less of that and a little more of the paper writing and grant writing, which was naive, but it was definitely the time. You know, the thinking still goes on. Still goes on.
Speaker A: You're basically creating a thing which enables science in the 21st century.
Speaker B: Right.
Speaker A: Maybe don't emphasize that so much in your free year tenure.
Speaker B: Right. It illustrates some of the challenges it does. And it's. People mean well, but we've gotten broken in a bunch of ways.
Speaker A: Certain things, programming, understanding the role of software engineering, programming society is a little bit lacking.
Speaker B: Exactly. Now I was in an electrical engineering position.
Speaker A: That's even worse there.
Speaker B: Yeah, they were very focused and so good people. And I had a great time. I loved my time, I loved my teaching. I loved all the things I did there. The problem was, this split was happening in this community. I loved. I saw people and I went, oh, my gosh, this is gonna be. This is not great. And so I happened, you know, fate. I had a class I had signed up for. I was trying to build an MRI system. So I had a kind of a radio instead of a radio, a digital radio class, a digital MRI class. And I had people sign up, two people signed up, then they dropped. And so I had nobody in this class and I didn't have any other courses to teach. And I thought, oh, I've got some time, and I'll just write a merger of numeric and numeray. I'll basically take the numeric code base at the features numrate was adding and then come up with a single array library that everybody can use. So that's where numpy came from, was my thinking, hey, I can do this, and who else is going to? Because at that point, I'd been around the community long enough and I'd written enough C code. I knew. I knew. The structure is, in fact my first contribution to Numeric had been writing the C API documentation that went in. The first documentation for numpy. For Numeric, sorry. This is Paul Dubois, David Asher, Conrad Hinson and myself. I got credit because I wrote this chapter, which is all the c API of numeric, all the c stuff. So I said, probably the one to do it. Nobody else is going to do this. So it's sort of out of a sense of duty and passion, knowing that. I don't think my academic. I don't think the department here is going to appreciate this, but it's the right thing to do.
Speaker A: Can we just linger on that moment? Because the importance of the way you thought and the action you took I feel is understated and is rare. And I would love to see so much more of it, because what happens as the tools become more popular, there's a split that happens, and it's a truly heroic and impactful action to, in that early split to step up. And it's like great leaders throughout history, like, get, what is the Braveheart, like, get on a horse and rile the troops? Because I think that can make a big difference. We have tensorflow versus Pytorch in the machine learning.
Speaker B: We have the same problem today.
Speaker A: Yeah, I wonder.
Speaker B: It's actually bigger.
Speaker A: I wonder if it's possible in the early days to rally the troops.
Speaker B: It is possible, especially in the early days. The longer it goes, the harder, and the more energy in the factions, the harder. But in the early days, it is possible, and it's extremely helpful, and there's a willingness there. But the challenge is there's usually not a willingness to fund it. There's not a willingness to. I was literally walking into a field saying, I'm gonna do this, and here I am. I have five kids at home now. Pressure builds. Sometimes my wife hears these stories, and she's like, you did what? I thought you were actually on a path to make sure we had resources and money.
Speaker A: Oh, wow.
Speaker B: But again, there's an aspect. I'm a very hopeful person. I'm an optimistic person by nature. I love people. I learned that about myself later on. Part of my religious beliefs actually lead to that, and it's why I hold them dear, because it's actually how I feel about, it's what leads me to these attitudes, sort of this hopefulness, and this sense of, yeah, it may not work out for me financially, or maybe, but that's not the ultimate gain. Like, that's a thing, but it's not. That's not the scorecard for me. And so I just wanted to be helpful. And I knew, and partly because these sci PI conferences, because the mainliness conversations, I knew there was a lot of need for this, right? And so I had this. It wasn't like I was alone in terms of no feedback. I had these people who knew, but it was crazy. Like people who at the time said, yeah, we didn't think you'd be able to do it. We thought it was crazy.
Speaker A: And also instructive, like, practically speaking, that you had a cool feature, that you were chasing the morphology, like the. Yes, it's not.
Speaker B: There's an end result.
Speaker A: It's not some visionary thing. I'm going to unite the community. You were like, correct. You were actually practically. This is what one person actually could do and actually build because that is.
Speaker B: Important, because you can get over your skis. You can definitely get over your skis. And in fact, this almost got me over my skis. Right. I would say, well, in retrospect, I hate looking back. I can tell you all the flaws with numpy. Right when I go into it, there's lots of stuff that I'm like, oh man, that's embarrassing. That was wrong. I wish I had somebody slap me with a wet fish there. Like I needed. In fact, what I'd wished I'd had was somebody with more experience and certainly library writing and array library. I wish I had me. I could go back in time and go do this, do that. There's a Morton bean. Because there's things we did that are still there that are problematic, that created challenges for later. And I didn't know it at the time, didn't understand how important that was, and in many cases didn't know what to do. There was pieces of the design of numpy I didn't know what to do until five years ago. Now I know what they should have been, but I didn't know at the time and I couldn't get the help anyway, so I wrote it. It took four months to write the first version, then about 14 months to make it usable. But it was that first four months of intense writing, coding, getting something out the door that worked. It was definitely challenging. And then the big thing I did was create a new type object called dtype. That was probably the contribution and then the fact that I added not just broadcasting but advanced indexing, so that you could do masked indexing and indirect indexing instead of just slicing for people who don't know.
Speaker A: And maybe you can elaborate numpy. I guess the vision in the narrowest sense is to have this object that represents n dimensional arrays and like at any level of abstraction you want. But basically it could be a black box that you can investigate in ways that you would naturally want to investigate such objects.
Speaker B: Yes, exactly. So you could do math on it easily.
Speaker A: Math on it easily.
Speaker B: So it had an associated library of math operations. And effectively scipy became an even larger set of math operations. So the key for me was I was going to write numpy and then move scipy to depend on numpy. In fact, early on, one of the initial proposals was that we would just write scipy and it would have the numeric object inside of it and it would be scipy array or something. That turned out to be problematic because numeric already had a little mini library of linear algebra and some functions and it had enough momentum, enough users that nobody wanted to, they wanted backward compatibility. One of the big challenges of numpy was I had to be backward compatible with both numeric and numeraide in order to allow both of those communities to come together. There was a ton of work in creating that backward compatibility that also created echoes in today's object. Like some of the complexity in today's object is actually from that goal of backward compatibility with these other communities, which if you didn't have that, you do something different, which is instructive because a lot of things are there. You think, what is that there for? It's like, well, it was a remnant. It's an artifact of its historical existence.
Speaker A: By the way, I love the empathy and the lack of ego behind that because I feel, you see that in the split in the JavaScript frameworks, for example, the arbitrary branching is, I think in order to unite people you have to kind of put your ego aside and truly listen to others. What do you love about Namore? What do you love about numeric? Actually get a sense. We were talking about languages earlier, sort of empathize to the culture of the people that love something about this particular API, the naming style or the actual usage patterns, and truly understand them and so that you can create that same draw. Completely agree. In the United I completely agree.
Speaker B: And you have to also have enough passion that you'll do it. It can't be just like a perfunctory, oh yes, I'll listen to you and then I'm not really that excited about it. So it really is an aspect, it's a philosophical, there's a Filia, there's a love of esteeming of others that's actually at the heart of what is sort of a life philosophy for me, right. That I'm constantly pursuing. And that helped, absolutely helped.
Speaker A: Makes me wonder in a philosophical, like looking at human civilization as one object, it makes me wonder how we can copy and paste Travis's in this book. Well, some aspects, maybe some aspects, right, right, exactly. Well I, it's a good question.
Speaker B: How do we teach this? How do we, how do we encourage it, how do we lift it?
Speaker A: Because so much of the software world, it's giant communities, right? But it seems like so much is moved by like little individuals. You talk about like Linus Torvald, it's like can you, could you have not, could you have had Linux without him? Could you.
Speaker B: It's like Guido and Python. Python. I mean, the sci PI community particularly. It's like I said, we wanted to build this big thing, but ultimately we didn't. What happened is we had mavericks and champions like Jon Hunter, who created Matt Plotlib, we had Fernando Perez who created ipython. And so we sort of inspired each other. But there's sort of a culture of this selfless giving, this stewardship mentality as opposed to ownership mentality, but stewardship and community focused. Community focused, but intentional work. Like not waiting for everybody else to do the work, but you're doing it for the benefit of others and not worried about what you're going to get. You're not worried about the credit, you're not worried about we're going to get. You're worried about. I later realized that I have to worry a little about credit. Not because I want the credit, because I want people to understand what led to the results. It's not about me, it's I want to understand this is what led to the result. So let's, I think doing, and this is what had no impact on the result. Like, let's. Let's promote. This is like you said, I want to promote the attributes that let, that help make us better off. How do we make more of Wes McKinney? Like, Wes McKinney was critical to the success of Python because of his creation of pandas, which is the roots of that were all the way back in numeric and Numarray and Numpy, where numpy created an array of records. Wes started to use that almost like a data frame, except it's an array of records and data frame. The challenge is, okay, if you want to augment it, add another column. You have to insert. You have to do all this memory movement to insert a column. Whereas data frames became, oh, I'm going to have a loose collection of arrays. So it's a record of arrays that is the heart of a data frame. And we thought about that back in the memory days, but Wes ended up doing the work to build it and then also the operations that were relevant for data processing. What I noticed is just that each of these little things creates just another tick, another up. So numpy ultimately took a little while. About six months in, people started joining me. Francesc Alted, Robert Kernae, Charles Harris. And these people are many of the unsung heroes. I would say people who are, they sometimes don't get the credit they deserve because they were critical both to support, like, you know, it's hard, and you want, you need some support. People need support. And I needed just encouragement, and they were helping encourage by contributing. And once. The big thing for me was when John Hunter, he had previously done kind of a simple thing called numerics to kind of, you know, between numeric and memory, he had a little high level tool that would just select each one for Matplotlib. In 2006, he finally said, we're going to just make numpy the dependency of Matplotlib. As soon as he did that, and I remember specifically when he did that, I said, okay, we've done it. That was when I knew we had succeeded. Success before then it was still sure. But that kind of started a roller coaster. And then 2006 to 2009, and then I've been floored by the, by what it's done. Like I had. I knew it would help. I had no idea how much it would help. Right. So.
Speaker A: And it has to do with, again, the language thing. It just. People started to think in terms of numpy.
Speaker B: Yes.
Speaker A: And that opened up a whole new way of thinking. And part of the story that you kind of mentioned, but maybe you can elaborate, is it seems like at some point in this story, Python took over science and data science, and not bigger than that. The scientific community started to think like programmers or started to utilize the tools of computers to do like, at a scale that wasn't done with Fortran, at this gigantic scale. They started to opening their heart. And then Python was the thing. I mean, there's a few other competitors, I guess Python, I think, really, really took over.
Speaker B: I agree. There's a lot of stories here that are kind of during this journey, because this is sort of the start of this journey in 2005, six. So my tenure committee, I applied for tenure in 2006, 2007. It came back, I split the department. I was very polarizing. I had some huge fans and then some people that said, no way. Right? So I was a polarizing figure in the department. It went all the way up to the university president. Ultimately, my department chair had the sway. And they didn't say no. They said, come back in two years and do it again. And I went. At that point, I was like, I had this interest in entrepreneurship, this interest in not the academic circles, how do we make industry work? So I do have to give credit to that exploration of economics because that led me. Oh, I had a lot of opinions. I was actually very libertarian at the time. I still have some libertarian trends. More of a. I'm more of a collectivist libertarian.
Speaker A: So you value broadly philosophically freedom.
Speaker B: I value broadly, philosophically, freedom, but I also understand the power of communities, like the power of collective behavior. And so what's that balance? Right. That makes sense. So by the time I was just, I gotta go out and explore this entrepreneur world. So I left academia. I said, no, thanks, called my friend Eric here, who had his company, was going. I said, hey, could I join you and start this trend? At that time, they were using Sci-Fi a lot. They were trying to get clients. And so I came down to Texas, and in Texas, where I sort of. It's my entrepreneur world, right. I left academia and went to entrepreneur world in 2007. So I moved here in 2007, kind of took a leap. Knew nothing really about business, knew nothing about a lot of stuff there. There's, you know, for a long time, I've kept some connections to a lot of academics because I still value it. I still love the scientific tradition. I still value the essence and the soul and the heart of what is possible. Don't like a lot of the administration and the kind of. We can go into detail about why and where and how this happens. What are the challenges?
Speaker A: I mean, I don't know, but I'm with you, so. Well, I'm still affiliated with MIT. I still love MIT because there's magic there.
Speaker B: Yeah.
Speaker A: And there's people I talk to, like researchers, faculty in those conversations and the whiteboard and just the conversation, that's magic there. All the other stuff, the administration, all that kind of stuff seems to, you don't want to say too harshly, criticize sort of bureaucracies, but there's a lagde that seems to get in the way of the magic.
Speaker B: Yeah.
Speaker A: And I don't. I'm still have a lot of hope that that can change because I don't often see that particular type of magic elsewhere in industry. So, like, we need that, and we need that flame going.
Speaker B: I agree.
Speaker A: And it's the same thing as, exactly as you said, it has the same kind of elements, like the open source community does. But then I, if you like, the reason I stepped away, the reason I'm here, just like you did in Austin, is like, if I want to build one robot, I'll stay at MIT, but if I want to build millions and make money enough to where I can explore the magic of that, then you can't. And I think that dance is that.
Speaker B: Translational dance has been lost a bit. And there's a lot of reasons for that. I'm certainly not an expert on this stuff, applying like anybody else, but I realized that I wanted to explore entrepreneurship, which I know and really figure out. And it's been a driving passion for 20 years, 25 years. How do we connect capital markets and company? Because, again, I fell in love with the notion that, oh, profit seeking on its own is not a bad thing. It's actually a coordination mechanism for allocating resources that in a mergent way that respects everybody's opinions. Right? So this is actually powerful. So I say all the time when I make a company and we do something that makes profit, what we're saying is, hey, we're collecting of the world's resources and voluntarily, people are asking us to do something they like, and that's a huge deal. And so I really like that energy. So that's what I came to do and to learn and to try to figure out, and that's what I've been kind of stumbling through for the past 14 years.
Speaker A: And that's 2007.
Speaker B: 2007.
Speaker A: And so you were still.
Speaker B: So numpy was just emerging. Just emerging. One thing I've done, it's worth mentioning because it emphasizes the exploratory nature of my thinking at the time. I said, well, I don't know how to fund this thing. I've got a graduate student I'm paying for, and I got no funding for him. And I had done some fundraising from the public to try to get public fundraising from my lab. I didn't really want to go out and just do the fundraising circuit the way it's traditionally done. So I wrote a book, and I said, I'm going to write a book, and I'm going to charge for it. It was called Guide to Numpy. And so ultimately, Numpy became documentation driven development because I basically wrote the book and made sure the stuff worked to the book would work. So it really helped actually make numpy become a thing. So writing that book, and it was not a, I mean, it's not a page turner, numpy, it's not a book you pick up and go, oh, this is great, over the fire. But it's where you could find the details. Like, how did all this work?
Speaker A: And a lot of people love that book.
Speaker B: And so a lot of people ended up, but I said, look, I need to, so I'm gonna charge for it. And I got some flack for that. Not that much. Just probably five angry messages, people yelling at me, saying I was bad guy for charging for this book.
Speaker A: One of them, which is Thomas. No, just kidding.
Speaker B: No, I haven't really had any interaction with him personally. Like, I said, but there were a few, but actually surprisingly not. There was actually a lot of people like, no, it's fine, you can charge for a book, that's no big deal. We know that's a way you can try to make money around open source. So what I did, I did in an interesting way. I said, well, my ideas around IP law and stuff, I love the idea. You can share something, you can spread it. The fact that you have a thing and copying is free, but the creation is not free. So how do you fund the creation and allow the copying in software? It's a little more complicated than that, because creation is actually a continuous thing. It's not like you build a widget and it's done. It's a process of emerging and continuing to create. But I wrote the book and had this market determined price thing. I said, look, I need, I think I said 250,000. If I make 250,000 from this book, I'll make it free. So as soon as I get that much money, or I said, five years, right? So there's a time limit that's forever.
Speaker A: Cool. I didn't know this story.
Speaker B: I released it on this. And it's actually interesting because one of the people who also thought that was interesting ended up being Chris White, who was the director of DARPA project that we got funding through at Anaconda. And the reason he even called us back, just because he remembered my name from this book and he thought that was interesting. Even though we hadn't gone to the demo days, we applied and the people said, yeah, nobody ever gets this without coming to the demo day first. This is the first time I've seen it. But it's because I knew Chris had done this and had this interaction. So it did have impact. I was actually really pleased by the result. I ended up. In three years, I made 90,000. So sold 30,000 copies by myself. I just put it up on use PayPal and sold it. And those are my first taste of kind of, okay, this can work to some degree. And all over the world, right from Germany to Japan, it was actually. It did work. And so I appreciated the fact that PayPal existed and I had a way to make to get the money. The distribution was simple. This is pre Amazon book stuff. So it was just published in a website. It was the popularity of Sci-Fi emerging and getting company usage. I ended up not letting it go the five years and nothing, trying to make the full amount, because a year and a half later I was at nthot. I had left academia as an thought. And I kind of had a full time job. And then actually what happened is the documentation people, there was a group that said, hey, we want to do documentation for Scipi as a collective. And they were essentially needing the stuff in the book. And so they kind of asked, hey, could we just use the stuff in your book? And at that point I said, yeah, I'll just open it up. So that's. But it has served its purpose. The money that I made actually funded my grad student. Like, it was actually, you know, I paid him 25,000 a year out of that money.
Speaker A: The funny thing is, if you do a very similar kind of experiment now with numpy or something like it, you could probably make a lot more. That's probably true because of the tooling and the community building.
Speaker B: Yeah, I agree.
Speaker A: And social media, there's just a virality to that kind of idea.
Speaker B: I agree. There'd be things to do. I've thought about that, and really I thought about a couple of books or a couple of things that could be done. There haven't even. I tried to hire a ghostwriter this year, too. To seek effect would help, but it didn't. Part of my problem is I've been so excited by a number of things that stepped in from that. So I came here, worked at nthot for four years. Graciously, Eric made me president. Then we started to work closely together. We actually helped him buy out his partner. It didn't end great. Unfortunately, Eric and I aren't real, aren't friends now. I still respect him. I have a lot. I wish we were. But he didn't like the fact that Peter and I started anaconda. Right. That was not, I mean, so there's two sides to that story. So I'm not going to go into it. Right, sure.
Speaker A: But you, it's human beings, and you wish you still could be friends.
Speaker B: I do. I do. It saddens me.
Speaker A: I mean, that's a story of great minds building great companies. Somehow it's sad that when there's that.
Speaker B: Kind of, and I hold him in esteem, I'm grateful for him. I think they're doing thought still exists. They're doing great work helping scientists. They still run the Sci-Fi conference. They have an R and D platform. They're selling now. That's a tool that you can go get today. Right. So they've been, thought has played a role in the Scipi, in supporting the community around Scipy. I would say they ended up not being able to. They ended up building a tool suite to write Gui applications. That's where they could actually make that the business could work. And so supporting Scipi and Numpy itself wasn't as possible. They tried. I mean, it was not just because, it was just because the business aspect, I wanted to build a company that could do that, could get venture funding better for worse. That's a longer story. We could talk a lot about that.
Speaker A: That's where Anaconda came to.
Speaker B: That's where an accountant came to be.
Speaker A: So let me ask you, it's a little bit for fun because you built this amazing thing. And so let's talk about like an old warrior looking over old battles. There's a sad letter in 2012 that you wrote to the Numpy mailing list announcing that you're leaving Numpy. And some of the things you've listed, some of the things you regret or not regret necessarily, but some things to think about. If you could go back and you could fix stuff about Nampai or both, sort of in a personal level, but also like looking forward, what kind of things would you like to see changed?
Speaker B: Good question. So I think there's technical questions and social questions right there. First of all, I wrote Numpy as a service and I spent a lot of time doing it. And then other people came help make it happen. Numpy succeeded because the work of a lot of people. So it's important people understand that. I'm grateful for the opportunity, the role I had, I could play, and I'm grateful that things I did had an impact, but they only had the impact they had because the other people that came to the story and so they were essential. But the way data types were handled, the way data types, we had array scalers, for example, that are really just a substitute for a type concept. Arrayscalers are actual Python objects, so that there's for every, for a 32 bit float or a 16 bit float or a 16 bit integer. Python doesn't have a natural, it's just one integer as one float. Well, what about these lower precision types, these larger precision types? So we had them in numpy so that you could have a collection of them, but then have an object in Python that was one of them. And there's questions about like, in retrospect, I wouldn't have created those, I would improve the type system, made the type system actually a Python type system, as opposed to currently it's a Python one level type system. I don't know if you know the difference between Python one and Python two, it's kind of technical and adept, but Python two, one of its big things that Guido did, it was really brilliant, was actually Python one. All classes, new objects were one. If you as a user wrote a class, it was an instance of a single python type called the class type. In Python two, he used a meta typing hook to actually go, oh, we can extend this and have users write classes that are new types. So he's able to have your user classes be actual types. And the Python type system got a lot more rich. I barely understood that at the time that numpy was written. I essentially, in numpy, created a type system that was Python one. Eradic it was. Every D type is an instance of the same type as opposed to having new D types be really just python types with additional metadata.
Speaker A: What's the cost of that? Is it efficiency? Is it usability?
Speaker B: It's usability primarily. The cost isn't really efficiency, it's the fact that it's clumsy to create new types. It's hard. And then one of the challenges, you want to create new types, you want a quaternion type or you want to add a new posit type or you want to. So it's hard. And now if we'd have done that well, when Numba came on the scene where we could actually compile python code, it would integrate with that type system much cleaner. And now all of a sudden you could do gradual typing more easily. You could actually have Python when you add numba. Plus better typing could actually be a. You'd smooth out a lot of rough edges.
Speaker A: But there's already. But are you talking about from the perspective of developers within numpy or users.
Speaker B: Of numpy because developers of new. Not really users of numpy so much it's the development of Numpy.
Speaker A: You're thinking about like how to design numpy so that it's contributors.
Speaker B: Yeah, the contributors are, it's easier, it's easier, it's less work to make it better and to keep it maintained. And where that's impacted things, for example, is the GPU. All of a sudden GPU's start getting added and we don't have them in numpy. Numpy should just work on GPU's. The fact that we'd have to download a whole other object called Cupid, have arrays on GPU's is just an artifact of history. There's no fundamental reason for it.
Speaker A: Well, that's really interesting. If we could go on that tangent briefly, is you have Pytorch and other libraries like Tensorflow that basically tried to mimic no PI. Like you've created a sort of platonic form of multi dimension.
Speaker B: Yeah, exactly. Well, the problem was they didn't realize that the platonic form has a lot of edges. They're like, well, we should cut those out before we present it.
Speaker A: So I wonder if you can comment, is there like a difference between their implementations? Do you wish that they were all using numpy in this abstraction over the GPU? And sorry to interrupt that there's GPU's ASics of, there might be other neuromorphic computing, there might be other kind of. Or the aliens will come with a new kind of computer, like an abstraction that numpy should just operate nicely over the things that are more and more and smarter and smarter with this. Multidimensional arrays.
Speaker B: Yeah, yeah. I have several comments there. We are working on something now called data dash APIs.org dot. Data dash API.org dot. You can go there today. And it's our answer. It's my answer. It's not just me, it's me and Ralph and Athen and Aaron and of companies are helping us at Quant site labs. It's not unifying all the arrays, it's creating an API that is unified. We do care about this and trying to work through it. I actually had the chance to go and meet with the Tensorflow team and the Pytorch team and talk to them after exiting anaconda, just talking about. Because the first year after leaving anaconda in 2018, I became deeply aware of this and realized that, oh, this split in the array community that exists today makes what I was concerned about in 2005 pretty parochial. It's a lot worse now. There's a lot more people, so perhaps the industry can sustain more stacks. There's a lot of money, but it makes it a lot less efficient. But I've also learned to appreciate it's okay to have some competition, it's okay to have different implementations, but it's better if you can at least refactor some parts. You're going to be more efficient if you can refactor parts.
Speaker A: Uh, it's nice to have competition over things, over innovative competition.
Speaker B: They're innovative.
Speaker A: Yeah, innovative. And then maybe on the infrastructure. Right, uh, whatever. However you define infrastructure, maybe it's nice to have cooperation.
Speaker B: Exactly. I agree. And I think. But it was interesting to hear the stories. I mean, Tensorflow came out of the c library. Jeff Dean wrote, I think there was basically a. How they were doing inference. Right? And then they realized, oh, we could do this tensorflow thing, that c library. Then what was interesting to me was the fact that both Google and Facebook did not. It's not like they supported Python or numpy initially. They just realized they had to. They came to this world, and then all the users like, hey, where's the numpy interface? Oh, then they kind of came late to it, and then they had these bolt ons, tensorflow's bolt on. I don't mean to offend, but it was so bad. It's the first time that I usually, I mean, one of the challenges I have is I don't criticize enough in the sense that I don't give people input enough.
Speaker A: I think it's universally agreed upon that, the botanical flow.
Speaker B: But I went to a talk given at a PI at Mallorca in Spain, and great guy came and gave a talk, and I said, you should never show that API again at a PI data conference. That's terrible. You're taking this beautiful system you've created and you're corrupting all these poor python people, forcing them to write code like that, or thinking they should. Fortunately, they adopted Keras, and Keras is better. Keras. Tensorflow is reasonable, but they bolted it on. Facebook did, too. Facebook had their own c library for doing inference, and they also had the same reaction they had to do this. One big difference is Facebook, maybe because the way it's situated in part of fair part of the research library, Tensorflow is definitely used, and they have to make. They couldn't just open it up and let the community change what that is, because I guess they were worried about disrupting their operations. Facebook's been much more open to having community input on the structure itself, whereas Google and Tensorflow, they're really eager to have community users, people use it and build the infrastructure, but it's much more walled. It's harder to become a contributor to Tensorflow itself.
Speaker A: This is a very difficult question to answer, and I don't mean to be throwing shade at anybody, but you have to wonder. It's the Microsoft question of when you have a tool like Pytorch or Tensorflow, how much are you tending to the hackers and how much are you tending to the big corporate clients?
Speaker B: Correct.
Speaker A: And so, like the ones that, do you tend to the millions of people that are giving you almost no money, or do you tend to the people, the few that are giving you a ton of money? I tend to stand with the people.
Speaker B: Right.
Speaker A: Cause I feel like if you nurture the hackers. You will make the right decisions in the long term that will make the companies happy.
Speaker B: I lean that way, too.
Speaker A: But then you have to find the right.
Speaker B: But it's a balance because you can lean to the hackers and run out of money.
Speaker A: Yeah, exactly. Exactly.
Speaker B: Which has been some of the challenge I've faced, in the sense that I would look at some of the experiments like numpy. The fact that we have this split is a factor of. I wasn't able to collect more money towards numpy development. I mean, I didn't succeed in the early days of getting enough financial contribution in umpire so that anybody could work on it. I couldn't work on it full time. I had to just catch an hour here, an hour there, and I basically not liked that. I've wanted to be able to do something about that for a long time and trying to figure out how. Well, there's lots of ways. I mean, possibly one could say. We had an offer from Microsoft, early days of Anaconda 2014. They offered to come by us. The problem was the right people at Microsoft didn't offer to buy us. And they were still. It was really. We were like a second. They had really bought. They just bought r. The r company called. It was not Rstudio, but it was another r company that was emergent. And it was kind of a. Well, we should also get a python play. But they were really double down on r. And so it was like.
Speaker A: It was where you would go to die. So it wasn't. It was before Satya was there.
Speaker B: Satya had just started.
Speaker A: Just started.
Speaker B: Right. And the offer was coming from someone two levels down from him.
Speaker A: Gotcha.
Speaker B: Right. And if it come from Scott Guthrie. So I got a chance to meet Scott Guthrie. Great guy. I like him. If it offered come from him, probably would be at Microsoft right now.
Speaker A: That'd be fascinating. That would be really nice, actually. Especially given what Microsoft has since done for the open source community. All those.
Speaker B: Yes, I think they're doing well. I really like some of the stuff they've been doing. They're still working and they've, you know, they've hired Guido now and they've hired a lot of python developers.
Speaker A: Guido's not Microsoft. I need to.
Speaker B: Which he retired. Then he came out of retirement and he's working out.
Speaker A: So I was just talking to him and he didn't mention this person. Well, I should. I know he loved Dropbox, but I wasn't sure what he was doing, what he was up to.
Speaker B: Well, he was kind of saying he'd retire, but. And it's literally been five years since I last sat down and really talked to Guido. Right. Guido is a technology expert. Right. He's a. So I came. I was excited because I'd finally figure out the type system for Numpy. I wanted to kind of talk about that with him and I kind of overwhelmed him.
Speaker A: Could you stay in that just for a brief moment? Because you're a fascinating person in the history of programming. He is a fascinating person. What have you learned from Guido about programming? About life?
Speaker B: Yeah, yeah, a lot, actually. I've been a fan of Guido's. We had a chance to talk some. I wouldn't say we talk all the time. Not only at all, but we talked enough to. I respect his fact. When I first started numpy, one of the first things I did was I asked Guido for a meeting with him and Paul Dubois in San Mateo. And I went and met him for lunch. And basically to say, maybe we can actually, part of the strategy for numpy was to get it into python three and maybe be part of Python. We talked about that and about that approach. Right.
Speaker A: I would have loved to be a flyer in the wall.
Speaker B: That was good. And over the years for Guido, I learned. So he was open, like he was willing to listen to people's ideas, right? And over the years now, generally, you know, I'm not saying universally that's been true, but generally that's been true. So he's willing to listen, he's willing to defer. Like on the scientific side, he would just kind of defer. He didn't really always understand what we were doing and he'd defer. One place where he didn't enough was we missed a matrix multiply operator that finally got added to python, but about ten years later than it should have. But the reason was because it takes a lot of effort. And I learned this while I was writing numpy. I also wrote tools to Python, I think of Python Dev. And I added some pieces to Python, like the memory view object. I wanted the structure of Numpy into Python. So we didn't get Numpy into Python, but we got the basic structure of it into Python so you could build on it. Nobody did for a while, but eventually database authors started to, and it's a lot better they did. And also Antoine Petro and Stephan Craw actually fixed the memory view object because I wrote the underlying infrastructure in C. But the python exposure was terrible until they came in and fixed it. Partly because I was writing numpy. And Numpy was the python exposure. I didn't really care about if you didn't have numpy installed. Anyway, Guido opened up ideas, technologically brilliant. I really got a lot of respect for him when I saw what he did with them with this type class merger thing. That was actually tricky. Right. And then willing to share, willing to share his ideas. So the other thing, early on in 1998, I said I wrote my first extension module. The reason I could is because he'd written this blog post on how to do reference counting. Right. And without it, I would have been lost. Right. But he was willing to at least try to write this post. And so he's been motivated. He's been motivated early on with Python, there's a computer science for everybody. You kind of have this early on desire to, oh, maybe we should be pushing programming to more people. So he had this populist notion, I guess, or populist sense, to learn that there's a certain skill, and I've seen it in other people too, of engaging with contributors sufficiently to. Because when somebody engages with you and wants to contribute to you, if you ignore them, they go away. So building that early contributor base requires real engagement with other people. And he would do that.
Speaker A: Can you also comment on this tragic stepping down from his position as the benevolent dictator for life over the wars?
Speaker B: You know, the walrus operator.
Speaker A: The walrus operator was the last battle. I don't know if that's the cause of it. But there's this for people who don't know. You can look up, there's the walrus operator, which looks like a colon equal sign.
Speaker B: Yeah.
Speaker A: And it actually does. Maybe the thing that you, that an equal sign should be doing.
Speaker B: Yeah, maybe.
Speaker A: Right, exactly. But it's just historically, equal sign means something else. It just means assignment. So he stepped down over this. What do you think about the pressure of leadership?
Speaker B: Some of the, you mentioned the letter I wrote in numpy at the time. That was a hard time, actually. I mean, you know, there's been really hard times. It was hard. You get criticized. Right. And you get pushed and you get. Not everybody loves what you do. Like anytime you do anything that has impact at all, you're not universally loved. Right. You get some real critics, and that's an important energy because it's impossible. If you did everything right, you need people to be pushing. But sometimes people can get mean. People can. I prefer to give people the benefit of the doubt. I don't immediately assume they have bad intentions and maybe for other, you know, maybe other, maybe that doesn't happen for everybody. They, for whatever reason, their past or their experience of people, they sometimes have bad, so they immediately attribute to you bad intentions. You're like, where did this come from? I mean, I'm definitely open to criticism, but I think you're misinterpreting the whole point, because I would get that sort of. When I started anaconda, I've been, sometimes I say to people, I know I'm a care enough about entrepreneurship to make some open source people uncomfortable, and I care enough about open source to make investors uncomfortable. So I sort of, you create kind of doubters on both sides.
Speaker A: So when you have, and this is just a plea to the listener and the public, I've noticed this, too, that there's a tendency, and social media makes this worse. When you don't have perfect information about the situation, you tend to fill the gaps with the. The worst possible or at least a bad story that fills those gaps. And I think it's good to live life, maybe not fully naively, but filling in the gaps with the good, with the best, with the positive, with the hopeful explanation of why you see this. So if you see somebody like you trying to make money on a book about numpy, there's a million stories around that that are positive and those are good to think about, to project positive intent on the people, because for many reasons, usually because people are good and they do have good intent. And also when you project that positive intent, people will step up to that, too.
Speaker B: Yes.
Speaker A: So, like, it's, it has, it's a great point. It has this kind of viral nature to it. And of course, what Twitter early on figured out and Facebook is that they can make a lot of money and engagement from the negative.
Speaker B: Yes.
Speaker A: And so, like, there's this. We're fighting this mechanism.
Speaker B: I agree.
Speaker A: Which is challenging.
Speaker B: It's like, easier.
Speaker A: It's just easier to be.
Speaker B: To be negative.
Speaker A: And then for some reason, something in our minds really enjoys sharing that and getting. Getting all excited about the negativity we do.
Speaker B: Yeah. But some protective mechanism, perhaps, that we're worried we're gonna eat if we don't.
Speaker A: Exactly. For us to be effective as a group of people in a software engineering project, you have to project positive intent. I think.
Speaker B: I totally agree. Totally agree. And I think that's very. So that happens in this. In the space. But Python has done a reasonable job in the past. But here's a situation where I think it's starting to get this pressure where it didn't have. I didn't know enough about what happened. I've talked to several people about it, and I know most of the steering committee members today. One person nominated me for that role, but it's the wrong role for me right now. I have a lot of respect for the Python developer space and the Python developers. I also understand the gap between computer science Python developers and array programming developers, or science developers. In fact, Python succeeds in the array space the more it has people in that boundary, and there's often very few. Like, I was playing a role in that boundary and, you know, working like, everything to try to keep up with the. With the what. Even what Gita was saying. Like, I'm a c programmer, but not a computer scientist. Like, I was an engineer and physicist and mathematician. And I don't, I didn't always understand what they were talking about and why they would have opinions the way they did. So you have to listen and try to understand. Then you also have to explain your point of view in a way they can understand. And that takes a lot of work, and that communication is always the challenge. And it's just what we're describing here about the negativity is just another form of that. Like, how do we come together? And it does appear we were wired anyway to at least have a. There's a part of us that enemy, you know, friend enemy. And we see, yeah, it's like, why are we wiring on the enemy front?
Speaker A: Yeah.
Speaker B: So why are we pushing that? Why are we promoting that so deeply?
Speaker A: Assume friend until proven otherwise.
Speaker B: Yes. Yes.
Speaker A: So. Cause you have such a fascinating mind in all this. Just ask you these questions. One interesting side on the python history is the move from Python two to python three. You mentioned move from Python one to Python two, but the move from Python two to Python three is a little bit interesting because it took a very long time. It broke in quite a small way, backward compatibility. But even that small way seemed to have been very painful for people. Is there lessons you draw?
Speaker B: Oh, tons of lessons.
Speaker A: From how long it took and how painful it seemed to be.
Speaker B: Yeah, tons of lessons. Well, I mentioned here earlier that numpy was written in 2005. It was in 2005 that I actually went to Guido to talk about getting numpy into python three. My strategy was to. Oh, we were moving to python three. Let's have that be. It seems funny in retrospect, because. Wait, Python three, that was in 2020 when we finally. And support for Python two, or at least 2017. The reason it took a long time, a lot of time. I think it was because one of the things is there wasn't much to like about Python three 3.03.1. It really wasn't until 3.3. Like, I consider Python 3.3 to be Python 3.0. It wasn't until Python 3.3 that I felt there's enough stuff in it to make it worth anybody using it. Right. And then three four started to be, oh yeah, I want that. And then 3.5 as the Matrix multiply operator. And now it's like, okay, we got to use that.
Speaker A: Plus the libraries that started leveraging some of the features of Python three.
Speaker B: Exactly. So it really. The challenge was. But it also illustrated a truism that when you have inertia, when you have a pop, when you have a group of people using something, it's really hard to move them away from it. You can't just change the world on them. And Python three, I think it fixed some things Guido had always hated. I don't think he didn't like the fact that print was a statement, wanted to make it a function. But in some sense that's a bit of gratuitous change to the language. And you could argue, and people have. But one of the challenges was there wasn't enough features and too many just changes without features. And so that empathy for the end user as to why they would switch wasn't there. I think also it illustrated just the funding realities. Like Python wasn't funded. Like it was also a project with a bunch of volunteer labor. Right. It had more people, so more volunteer labor, but it was still. It was fun in the sense that Lis Guido had a job, and I've learned some of the behind the scenes on that now, since talking to people who lived through it and maybe not on air, we can talk about some of that, but it's interesting to see. But Guido had a job, but his full time job wasn't just work on Python, he had other things to do.
Speaker A: Just wild.
Speaker B: It is wild, isn't it?
Speaker A: It's wild how few people are funded.
Speaker B: Yes.
Speaker A: How much impact they have. Maybe that's a feature, not a bug. I don't know, maybe.
Speaker B: Yes, exactly. At least early on. Like it's sort of. I know, yeah.
Speaker A: It's like Olympic athletes are often severely underfunded, but maybe that's what brings out the greatness, perhaps.
Speaker B: Yes, correct. No, exactly. Maybe this is essential part of it, because I do think about that in terms of, I currently have an incubator for open source startups. What I'm trying to do, right, now is create the environment I wished had existed. When I was leaving academia with Numpy and trying to figure out what to do, im trying to create those opportunities and environments. Thats what drives me still is how do I make the world easier for the open source entrepreneur.
Speaker A: I could probably stay in numpy for a long time but this is fun question. Andre Kapathy leads the Tesla autopilot team and hes also one of the most legit programmers I know. It's like he builds stuff from scratch a lot and that's how he builds intuition about how a problem works. He just built it from scratch and I always love that. And the primary language he uses is python for the intuition building. But he posted something on Twitter saying that they got a significant improvement on some aspect of their data loading, I think by switching away from np square root. So the numpy's implementation of square root to math square root. And then somebody else commented that you can, you can get even a much greater improvement by using the vanilla python square root, which is like power 0.5, power 0.5. And it's fascinating to me. I just wanted to. So that. Absolutely, that was some shade throwing at some.
Speaker B: No, no, but also just we're talking.
Speaker A: About it's a, a good way to ask the trade off between usability and efficiency broadly in numpy, but also on these specific weird quirks of a single function.
Speaker B: Yeah. So on that point, if you use a numpy math function on a scalar, it's going to be slower than using a python function on that scalar because the math object in numpy is more complicated because you can also call that math object on an array. Effectively it goes through a similar machine. There aren't enough of the which you would do and you could do like checks and fast paths. So yeah, if you're basically doing a list, if you run over a list, in fact, for problems that are less than 1000, even maybe 10,000 is probably the, if you're going more than 10,000, that's where you definitely need to be using arrays. But if you're less than that and for reading, if you're doing a reading process and essentially it's not compute bound, it's IO bound. And so you're really taking lists of thousand at a time and doing work on it. Yeah, you could be faster just using Python straight up Python.
Speaker A: See, but also, and then this is the side to interpret. There's the fundamental questions when you look at the long arc of history. It's very possible that NP square is much faster. It could be so like, in terms of like, don't worry about it. It's the evils of over optimization or whatever. All the different quotes around that is sometimes obsessing about this particular little quirk is not efficient.
Speaker B: Like for somebody, like if you're trying to optimize your path, I mean, I agree, premature optimization creates all kinds of challenges, right? Because now. But you may have to do it.
Speaker A: I believe the quote is the root of all evil.
Speaker B: Root of all evil. Right. Let's give Donald Knuth, I think, or somebody else.
Speaker A: Well, doc, Newt is kind of like Mark Twain. People just attribute stuff to him.
Speaker B: I don't, and it's fine because it's brilliant. So, no, I was a latex user myself and so I have a lot of respect. And he did more than that, of course. But yeah, someone I really appreciate in the computer science space. Yeah, I don't, I think that's appropriate. There's a lot of little things like that where people actually, if you understood it, you go, yeah, of course that's the case. And the other part, the other part I didn't mention, and Numba was a thing we wrote early on. And I was really excited by Numba because it's something we wanted. It was a compiler for Python syntax, and I wanted it from the beginning of writing numpy because of this function question. The power of arrays is really that you can write functions using all of it. It has implicit looping, right? So you don't worry about, I write this n dimensional for loop with four loops for, for statements. You just say, oh, big four dimensional array. I'm going to do this operation, this plus this minus this reduction, and you get this. It's called vectorization in other areas. But you can basically think at a high level and get massive amounts of computation done with the added benefit of, oh, it can be parallelized easily, it can be put in parallel. You don't have to think about that. In fact, it's worse to go decompose your, you write the for loops and then try to infer parallelism from for loops. That's actually a harder problem than to take the array problem and just automatically parallelize that problem. That's what. And so functions in numpy are called universal functions, u funcs. So square root is an example of a U func. There are others sine cosine, add, subtract. In fact, one of those first libraries to scipy was something called special where I added Bessel functions and all these special functions that come up in physics, and I added them as u funcs so they could work on arrays. So I understood u funks very, very well from day one. Inside of numeric. That was one of the things we tried to make better in numpy was how do they work? Can they do broadcasting? What does broadcasting mean? But one of the problems is, okay, what do I do with a python scalar? So what happens? The Python scaler gets broadcast to a zero dimensional array and then it goes through the whole same machinery as if it were a 10,000 dimensional array, and then it, then it unpacks the element and does the addition. That's not to mention the function it calls in the case of square root is just the clib square root. In some cases, like Python's power, there's some optimizations they're doing that can be faster than just calling the c lib.
Speaker A: Square root in the interpreter or in.
Speaker B: The no, in the C code, in.
Speaker A: The python runtime, in the python, they really optimize it and they have the freedom to do that because they don't have to worry about, it's just a.
Speaker B: Scalar, it's just a scaler, they don't have to worry about the fact that, oh, this could be an object with many pieces. The U func machinery is also generic in sense that typecasting and broadcasting, broadcasting is the idea of, I'm going to go, I have a zero dimensional array, I have a scalar with a four dimensional array and I add them. Oh, I have to coerce the shape of this guy to make it work against the whole four dimensional array. So it's the idea of I can do a one dimensional array against a two dimensional array and have it make sense.
Speaker A: Well, that's what numpy does is it challenges you to reformulate, rethink your problem as a multi dimensional array problem versus like move away from scalars completely.
Speaker B: Right? Exactly.
Speaker A: Yeah, exactly.
Speaker B: In fact, that's where some of the edge cases boundaries are. Is that, well, they still there? And this is where arrayscalers are particular. So arrays gets, are particularly bad in the sense that they were written so that you could optimize the math on them, but that hasn't happened. And so their default is to use, is to coerce the arrays together to a zero dimensional array and then use the numpy machinery. That's what. And you could specialize, but it doesn't happen all the time. So in fact, when we first wrote Numba, we do comparisons and say, look, it's 1000 x speedup. We're lying a little bit in the sense that well, first do the 40 x slowdown of using arrayscalers inside of a loop, because if you just use Python scalers you'd already be ten times faster. But then we would get 100 times faster over that using just compilation. But what we do is compile the loop from out of the interpreter to machine code. That's always been the power of Python. Is this extensibility so that you can, people say, oh, Python's so slow. Well sure, if you do all your logic in the runtime of the Python interpreter, yeah, but the power is that you don't have to, you write all the logic. What you do in the high, the high level is just high level logic. And the actual calls you're making could be on gigabyte arrays of data. And that's all done at compiled speeds. And the fact that integration is one can happen, but two is separable. That's one of the language. Like Julia says, we're going to be all in one. You can do all of it together. And then there's the jury's out. Is that possible? I tend to think that you're going to, there's separate concerns there. You want to precompile, in fact, generally you will want to precompile some of your loops. Like Sci-Fi is a compilation step. To install Sci-Fi it takes about 2 hours. If you have many machines, maybe you can get it down to 1 hour. But to compile those libraries takes a while. You don't want to do that at runtime. You don't want to do that all the time. You want to have this precompiled binary available that you're then just linking into. So there's real questions about the whole source code. Running binary code is more than source code. It's create an object code, it's the linker, it's the loader. How does that interpret it inside of the virtual memory space? There's a lot of details there that actually I didn't understand for a long time until I, you know, read books on the topic. And it led to the more you know, the better off you are and you can do more details. But sometimes it helps you with abstractions too.
Speaker A: Well, the problem, as we mentioned earlier with abstractions is you kind of sometimes assume that whoever implemented this thing had your case in mind and found the optimal solution.
Speaker B: Yes.
Speaker A: Or like you assume certain things. I mean, there's a lot of.
Speaker B: Correct.
Speaker A: One of the really powerful things to me early on, I mean, it sounds silly to say, but with Python, probably one of the reasons I fell in love with it is dictionaries.
Speaker B: Yes.
Speaker A: So obviously probably most languages have some mapping concept, some mapping concept, but it felt like it was a first class citizen and it was just my brain was able to think in dictionaries. But then there is the thing that I guess I still use to these days, order dictionaries, because that seems like a more natural way to construct dictionaries. And from a computer science perspective, the running time cost is not that significant. But there's a lot of things to understand about dictionaries that the abstraction kind of doesn't necessarily incentivize you to understand.
Speaker B: Right? Do you really understand the notion of a hashmap and how the dictionary is implemented? But you're right, dictionaries are a good example of an abstraction that's powerful. And I agree with you. One of the love, I agree, I love dictionaries too. It took me a while to understand that. Once you do, you realize, oh, they're everywhere, and Python uses them everywhere too, like it's actually constructed. One of the foundational things is dictionaries, and it does everything with dictionaries. So it is, it's powerful order dictionaries came later, but it is very, very powerful. It took me a little while coming from just the array programming entirely to understand these other objects like dictionaries and lists and tuples and binary trees. Like I said, I wasn't a computer scientist. I studied arrays first, and so I was very array centric. And you realize, oh, these others do have purposes and value. Actually. I agree.
Speaker A: There's a friendliness about like one way to think about arrays is arrays are just full of numbers, but to make them accessible to humans and make them less error prone to human users, sometimes you want to attach names, human interpretable names that are sticky to those arrays. So that's how you start to think about dictionaries.
Speaker B: Yes, good point.
Speaker A: You start to convert numbers into something that's human interpretable. And that's actually the tension I've had, correct with numpy, because correct. I built so much tooling around human, human interpretability and also protecting me from a year later, not making the mistakes by being. I wanted to force myself to use English versus numbers.
Speaker B: Yes, there's a project called labeled arrays. Like very early it was recognized that, oh, we need, we're indexing numpy, which is numbers, all the columns and particularly the dimensions. I mean, if you have an image, you don't necessarily need to label each column or row. But if you have a lot of images or you have another dimension, you'd least like to label the dimension as this is x, this is y, this is z, or this is give us some human meaning or some domain specific meaning. That was one of the impetuses for pandas, actually, was just, oh, we do need to label these things. And Labelarray was an attempt to add that lighter weight version of that. And there's been, that's an example of something I think numpy could add, could be added to numpy. But one of the challenges, again, how do you fund this? Like I said, one of the tragedies I think, is that I never had the chance, I was never paid to work on numpy. Right. So I've always just done in my spare time, always taken from one thing, taken from another thing to do it. And at the time, I mean, today it would be the wrong day. I'm today, like, paying me to work on numpy now would not be a good use of effort. But we are finally at Quant site labs. I'm actually paying people to work on numpy and Sci-Fi which is I'm thrilled with. I'm excited by. I wanted to do that. That's why I wanted to do from day one. It just took me a while to figure out a mechanism to do that.
Speaker A: Even like in the university setting, respecting that, like pushing students, young minds, young graduate students to contribute and then figuring out financial mechanisms that enable them to contribute and then sort of reward them for their innovative scientific journey. That would be nice. But then also just a better allocation of resources. It's a 20 year anniversary since 911, and I was just looking, we spent over $6 trillion in the Middle east after 911 in the various efforts there. And sort of to put politics and all that aside is just, you think about the education system, all the other ways we could have possibly allocated that money to me to take it back. The amount of impact you would have by allocating a little bit of money to the programmers.
Speaker B: Yeah.
Speaker A: That build the tools that run the world is fascinating.
Speaker B: I mean, it is.
Speaker A: I don't know, I think, again, there is some aspect to being broke as somewhat of a feature, not a bug.
Speaker B: That you make sure that you're managed that, right?
Speaker A: No, I know, but I don't think that's a big part. So it's like, I think you can have enough money and actually be wealthy while maintaining your values.
Speaker B: Agreed.
Speaker A: I think.
Speaker B: Agreed. There's an old adage that nations that trade together don't go to war together. I've often thought about nations that code together, because one thing I love about open source is it's global, it's multinational, there aren't national boundaries. One of the challenges with business and open source is the fact that, well, business is national. Businesses are entities that are recognized in legal jurisdictions and have laws that are respected in those jurisdictions, and hiring, but the open source ecosystem, it's not there currently. One of the problems we're solving is hiring people all over the world. It's a global effort, and I've had the chance to work, and I've loved the chance. I've never been to Iran, but I once had a conference where I was able to talk to people there and talk to folks in Pakistan. Never been there, but we had a call, and there were people there, like, just scientists and normal people. And, you know, and there's a certain amount of humanizing. Right. That gets away from the like. We often get the memes of society that bubble up and get or get discussed, but the memes are not even an accurate reflection of the reality of what people are.
Speaker A: Well, if you look at the major power centers that are leading to something like cyber war in the next few decades, it's the United States, it's Russia and China, and those three countries in particular have incredible developers. So if they work together, I think that's one way the politicians can do their stupid bickering. But, like, there's a layer of infrastructure of humanity, if they collaborate together, that I think can prevent major military conflict, which would, I think, most likely happen at the cyber level versus the actual hot war level.
Speaker B: You're right. No, I think that's a good prediction.
Speaker A: Nations that code together don't go to.
Speaker B: War together don't go to war together. That's a hope, right? That's one of the philosophical hopes, but, yeah.
Speaker A: So you mentioned the project of Numba, which is fascinating. So from the early days, there was kind of a pushback on Python that it's not fast. If you want to write something that's fast, you see c. If you want to write something that's usable and friendly but slow, you use python. What is numba? What is its goal? How does it work?
Speaker B: Great. Yeah. Yes. That's what the argument and the reality was. People would write high level code and use compiled code, but there's still user store use cases where you want to write Python, but then have it still be fast. You still need to write a for loop like before Numba, it was always don't write a for loop, write it in a vectorized way, put in an array and often that can make a memory trade off. Quite often you can do it, but then you make maybe use more memory because you have to build this array of data that you don't necessarily need all the time. Numba, it started from a desire to have a vectorize that worked. Vectorize was a tool in numpy. It was released, you give it a Python function and it gave you a universal function, a U func that would work on arrays. So you get a function that just worked on a scalar like you could make. The classic case was a simple function that an if then statement in it. So sine x over x function, sync function. If x equals zero, return one. Otherwise do sin x over x. The challenge is you don't want that loop peg one in Python, so you want a compiled version of that. But the u, the vectorize in numpy would just give you a Python function. So it'd take the array of numbers and at every call do a loop back into Python. So it was very slow. It gave you the appearance of a U funct, but it was very slow. So I always wanted a vectorize that would take that python scalar function and produce a U func working on binary native code. In fact, I had somebody work on that with Pypy to see if Pypy could be used to produce a U func like that. Early on in 2009 or something like that, 2010, it didn't work that well. It was kind of pretty bulky. But in 2012, Peter and I had just started anaconda. I had just, I'd learned to raise money. That's a different topic. But I'd learned to raise money from friends, family and fools, as they say.
Speaker A: It's a good line.
Speaker B: Oh, that's a good line. But so we're trying to do something. We were trying to change the world. Peter and I are super ambitious. We wanted to make array computing and we had ideas for really what's still the energy right now? How do you do at scale data science? And we had a bunch of ideas there. But one of them I had just talked to people about LlVM and I was like, there's a way to do this. I heard about my friend Dave Beasley at a compiler course. So I was looking at compilers and I realized, oh, this is what you do. And so I wrote a version of Numba that just basically mapped Python bytecode to LlvM. Nice and the first version is like, this works and it produces code. That's fast. This is cool for obviously a reduced subset of Python. I didn't support all the Python language. There had been efforts to speed up Python in the past, but those efforts were, I would say, not from the array computing perspective, not from the perspective of wanting to produce a vectorize improvement. They were from the perspective of speeding up the runtime of Python, which is fundamentally hard because Python allows for some constructs that aren't, you can't speed up. It's this generic, there's this variable. I, from the start, did not try to replicate Python semantics entirely. I said, I'm going to take a subset of the Python syntax and let people write syntax in Python. But it's kind of a new language really.
Speaker A: So it's almost like for loops, like.
Speaker B: Focusing on, for loops, scalar arithmetic, typed, really typed language, a typed subset, that was the key. But we wanted to add inference of types so you didn't have to spell all the types out, because when you call a function, so python is typed, it's just dynamically typed, so you don't tell it what the types are. But when it runs, every time an object runs, there's a type for the variables, you know what it is. And so that was the design goals of Numba, were to make it possible to write functions that could be compiled and have them use for numpy arrays, like they needed to support numpy arrays.
Speaker A: So how does it work? Do you add a comment within Python that tells to do like, how do.
Speaker B: You help out a compiler, know what to do? There isn't much, actually. You don't. It's kind of magical in the sense that it just looks at the type of the objects and then as type inference to determine any of the other intermediate variables it needs. And then it was also because we had a use case that could work early. Like one of the challenges of any kind of new development is if you have something that to make it work, it was going to take you a long time. It's really hard to get out off the ground. If you have a project where there's some incremental story, it can start working today and solve a problem, then you can start getting it out there, getting feedback, because Numba today, now Numba is nine years old today. The first two, three versions were not great, but they solved a problem and so people could try it and we could get some feedback on it, not great.
Speaker A: And that it was very focused, very.
Speaker B: Fragile, very subset, the subset, it would actually compile was small. And so if you wrote Python code and said, so, the way it worked is you write a function and you say, use decorators. So decorators are just these little constructs let you decorate code with an aim. The would take your python function and actually just compile it and replace the Python function with another function that interacts with this compiled function.
Speaker A: Got it.
Speaker B: Would just do that. We went from Python bytecode, then we went to ast. Writing compilers. Actually, I learned a lot about why computer science is taught the way it is, because compilers can be hard to write. They use tree structures, they use all the concepts of computer science that are needed, and it's actually hard to, it's easy to write a compiler and then have it be spaghetti code. Like the past has become challenging and we ended up with three versions of Numba. Right? Numba got written three times.
Speaker A: What programming language is number written in Python?
Speaker B: Wait, okay, yeah, Python, really?
Speaker A: That's fascinating.
Speaker B: Yeah. So Python. But then the whole goal of Numba is to translate Python bytecode to Llvm. And so Llvm actually does the code generation. In fact, a lot of times they'd say, yeah, it's super easy to write a compiler if you're not writing the parser nor the code generator. Right.
Speaker A: So for people who don't know, LLVM is a compiler itself. So your compiler.
Speaker B: Yeah, it's really badly named low level virtual machine, which that part of it is not used. It's really low level Chris.
Speaker A: He doesn't mean that.
Speaker B: Love Chris. But the name makes you imply that the virtual machine is what it's all about. It's actually the irritated and the library, the code generation. That's the real beauty of it. The fact that what I love about LLVM was the fact that it was a plateau you could collaborate on, right. Instead of the internals of GCC or the internals of the intel compiler, like how do I extend that? And here's a place we could collaborate, and we were early. I mean, people had started before. It's a slow compiler, it's not a fast compiler. So for some kind of Jits, like Jits are common in a language because one, every browser has a JavaScript JIT. It does real time compilation of the JavaScript to machine code.
Speaker A: For people who don't know, JIt is just in time compilation.
Speaker B: Thank you. Yeah, just in time compilation. They're actually really sophisticated. In fact, I got jealous of how much effort was put into the JavaScript jets.
Speaker A: Yes, well, it's kind of incredible what they've done with JavaScript jets.
Speaker B: Yeah, I completely agree. I'm very impressed. But number was an effort to make that happen with Python. And so we used some of the money raised from Anaconda to do it. And then we also applied for this DARPA grant and used some of that money to continue the development. And then we used proceeds from service projects we would do. We get consulting projects that we would then use some of the profits to invest in Numba. So we ended up with a team of two or three people working on Numba. It was a fits and starts, right. And ultimately the fact that we had a commercial version of it also we were writing. So part of the way I was trying to fund numbas, say well lets do the free number and then well have a commercial version of Numba called Numba Pro. And what number pro did is it targeted GPU's. So we had the very first Cudajit and the very first compiler that in 2012 for 13 you could run not just a view funk on cpu, but a u funk on GPU's and it would automatically paralyze it and get thousand x speed up.
Speaker A: And thats an interesting funding mechanism because, you know, large companies or larger companies care about speed in just this way. So it's exactly a really good way.
Speaker B: Yeah, there's been a couple of things, you know, people will pay for. One, they'll pay for really good user interfaces, right. And so I'm always looking for what are the things people will pay for that you could actually adapt to the open source infrastructure. One is definitely user interfaces. The second is speed, like a better runtime, faster runtime.
Speaker A: And then when you say people, you mean like a small number of people pay a lot of money. But then there's also this other mechanism. That's true. A ton of people pay. That's true a little bit. First I gotta. We mentioned anaconda, we mentioned friends, family and fools. So Anaconda is yet another. So there's a company, but there's also a project.
Speaker B: Correct.
Speaker A: That is exceptionally impactful in terms of, for many reasons, but one of which is bringing a lot more people into the, into the community of folks who use Python. So what is anaconda, what is its goals? Maybe what is Conda versus anaconda?
Speaker B: Yeah, I'll tell you a little bit the history of that. Because Anaconda, we wanted to scale Python because Peter and I had the goal of when we started Anaconda, Anaconda we actually started as continuum analytics, was the name of the company that started it got renamed Anaconda in 2015. But we said, we want to scale analytics. Numpy is great, pandas is emerging, but these need to run at scale with lots of machines. The other thing we wanted to do was make user interfaces that were web. We wanted to make sure the web did not pass by the Python community, that we had a ways to translate your data science to the web. So those are the two kind of technical areas we thought, oh, well, build products in this space. And that was the idea very quickly in. But of course, the thing I knew how to do was to do consulting, to make money and to make sure my family and friends and fools that had invested didn't lose their money. So it's a little different than if you take money from a venture fund. If you take money from a venture fund, the venture fund, they want you to go big or go home. And they're kind of like expecting nine out of ten to fail or 99 out of ten, 100 to fail. It's different. I was at a Barbell strategy. I was like, I can't fail. I mean, I may not do super well, but I cannot lose their money. So I'm going to do something I know can return a profit, but I want to have exposure to an upside. So that's what happened in Akan. There's lots of things we did not well in terms of that structure, and I've learned from since and how to do it better, but we did a really good job of kind of attracting the interest around the area to get good people working and then get funnel some money on some interesting projects. Super excited about what came out of our energy there, like, a lot did.
Speaker A: So what are some of the interesting projects?
Speaker B: Dask Numba, bokeh, Conda. There was a data shader panel, Holovis. These are all tools that are extremely relevant in terms of helping you build applications, build tools, build faster code. Jupyterlab. Jupyterlab came out of this, too. Fascinating.
Speaker A: Okay, so Bokeh does plotting. Is that.
Speaker B: Okay, does plotting? So Bokeh was one of the foundational things to say. I want to do plot in python, but have the things show up in a web, right?
Speaker A: That's right. That's right. So plotting, to me still, with all due respect to Matt, plot, lib and Bokeh is. Feels like still an unsolved problem. Not problem.
Speaker B: It is. It's a big problem.
Speaker A: Right. Because you're, I mean, I don't know, visualization broadly.
Speaker B: Yes. I think we got a pretty good API story around certain use cases of plotting. But there's a difference between static plots versus interactive plots versus. I'm an end user, I just want to write a simple Panda started the idea of here's a data frame, I'm going to dot plot, I'm just going to attach plot as a method to my object, which was a little bit controversial, but works pretty well, actually, because there's a lot less you have to pass in. You can just say, here's my object, you know what you are, you tell the visualization what to do. And there's things like that that have not been super well developed entirely. But Bokeh was focused on interactive plotting, so it's a short path between interactive plotting and application dashboard application. And there's some incredible work that got done there. It was a hard project because then you're basically doing JavaScript and Python. So we wanted to tackle some of these hard problems and try to just go after them. We got some DARPA funding to help and it was super helpful. Funny story there. We actually did two DARPA proposals, but one we were five minutes late for, and DARPA has a very strict cutoff window. And so we had two proposals, one for the bokeh and one for actually Numba. And the other work, which one were you late for? The foundational numerical work. So Bokeh got funded. Fortunately, Chris let us use some of the money to fund still some of that other foundational work, but it wasn't as. Yeah, his hands were tired, he couldn't do anything about it. That was a whole interesting story.
Speaker A: So one of the incredible projects that you worked on is Conda.
Speaker B: Yes. How does that came about? Yeah, Conda. It was early on, like I said, with Scipi. Scipi was a distribution masquerade in the library, and he heard me talking about compiler issues and trying to get the stuff shipped and the fact that people can use your libraries if they have it. So for a long time we'd understood the packaging problem in Python. One of the first things we did at continuum analytics became anaconda, was organized the PI data ecosystem in conjunction with Numfocus. We actually started Numfocus with some other folks in the community the same year we started anaconda. I said, we're going to build a corporation, but we also got to reify the community aspect and build a nonprofit. So we did both of those.
Speaker A: Can we pause real quick and can you say, what is pypy? The Python package index story of packaging in Python.
Speaker B: Yeah, that's what I'm going to get to, actually, this is exactly the journey I'm on, is to sort of explain packaging in Python. I think it's best expressed through the conversation I had with Guido at a conference where I said packaging is kind of a problem. And Guido said, I don't ever care about packaging. I don't use it, I don't install new libraries. I'm like, I guess if you're the language creator and if you need something, you just put it in the distribution, maybe you don't worry about packaging. But Guido has never really cared about packaging and never really cared about the problem of distribution, somebody else's problem. And that's a fair position to take, I think, as a language creator. In fact, there's a philosophical question about should you have different development packaging managers, should you have a package manager per language? Is that really the right approach? I think there are some answers of it is appropriate to have development tools and there's an aspect of development tool that is related to packaging. And every language should have some story there to help their developers create.
Speaker A: So it should have language specific language.
Speaker B: Development tools that relate to package managers. But then there's a very specific user story around package management that those language specific package managers have to interact with and currently aren't doing a good job of that. That was one of the challenges that not seeing that difference and still exists in the difference today. Conda always was a user. I'm going to use Python to do data science. I'm going to use Python to do something. How do I get this installed? It was always focused on that. So it didn't have like a develop, you know, classic example is Pip has a pip develop. It's like, I want to install this into my current development environment today. Now, Connor doesn't have that concept because it's not part of the story.
Speaker A: For people who don't know, Pip is a Python specific packaging manage package manager.
Speaker B: Right.
Speaker A: That's, that's exceptionally popular. That's probably like the default thing.
Speaker B: You default user. Yeah. And so the story there emerged, because what happened is in 2012, we had this meeting at the Googolplex and Guido was there to come talk about what we're going to do, how are we going to make things work better. And Wes McKinney, me, Peter. Peter has a great photo of me talking to Guido and he pretends we're talking about this story. Maybe we were, maybe weren't, but we did at that meeting, talk about it and ask Guido. Guido, we need to fix packaging in Python. People can't get the stuff. And he said, go fix it yourself. I don't think we're going to do it.
Speaker A: All right, the origin story right there.
Speaker B: All right. You said, okay, you said to do this ourselves. At the same time, people did start to work on the packaging story in Python. It just took a little longer. So in 2012, kind of motivated by our training courses we were teaching very similar to what you just mentioned about your mother. It was motivated by the same purpose. How do we get this into people's hands? And it's this big long process. It takes too expensive. It was actually hurting numpy development because I would hear people were saying, don't make that change to numpy because I just spent a week getting my python environment. And if you changed, if you change numpy, you have to reinstall everything. And reinstalling such a pain. Don't do it. I'm like, wait, okay, so now we're not making changes to a library because of the installation problem that'll cause for end users. Okay, there's a problem with pack, there's a problem with installation. We got to fix this. So we said, we're going to make a distribution in Python. And we'd previously done that. Previously done that at nthought, I wanted to make one that we gave away for free. Everyone could just get like, that was critical that we just get it. You know, it wasn't tied to a product, it was just, you could get it. And then we had constantly thought about, well, do we just leverage RPM? But the challenge had always been, we want a package manager that works on Windows, Mac OS X and Linux the same. Right. And it wasn't there. Like, you don't have anything like that. You have.
Speaker A: And for people who don't know, RPM is red hat. Package manager, operating system specific. Package manager.
Speaker B: Correct. It's an operating specific. Yes, exactly.
Speaker A: So do you create. The design question is, do you create an umbrella package manager that cross operating system?
Speaker B: Yes.
Speaker A: And a neighboring design question is, do you also create a package manager that spans multiple programming languages?
Speaker B: Exactly. That was the world we faced. And we decided to go multiple operating systems, multiple and programming language independent, because even Python in particular, what was important was scipy has a bunch of four chan in it, and Scikit Learn has links to a bunch of c. There's a lot of compiled code. And the python package managers, especially early on, didn't even support that. So in 2000. So we released anaconda, which was just a distribution of libraries. But we started work on Conda in 2012. 1st version of Conda came out in early 2013, summer of 2013, and it was a package manager so you could say Conda installs scikit learn. In fact that was the scikit learn was a fantastic project that emerged. It was the classic example of the scikits. I talked to you earlier about scipy being too big to be a single library. Well, what the community had done is said let's make sidekits. And there's psychic image, there's scikit learn, there's a lot of sidekits. And it was a fantastic move the community did. I didn't do it. I was like, okay, that's a good idea. I didn't like the name, I didn't like the fact you type psychic image. I was like, that's got to be simpler. Sk learn, we got to make that smaller. I don't like typing all this stuff from imports, so I was kind of a pressure that way. But I love the energy, I love the fact that they went out and they did it and people, Jared Millman and then of course Gael. And there's people I'm not even naming that scikit learn really emerged this fantastic.
Speaker A: Project and the documentation around that is also incredible.
Speaker B: Exactly.
Speaker A: I don't know who did that, but they did a great job.
Speaker B: A lot of people in, in Rhea, a lot of people like a lot of european contributors. Andreas, there's some Andreas in the US. There's a lot of just people I just adore, I think are amazing people. Awesome use of Sci-Fi right? I love the fact that they were using Sci-Fi effectively, do something I love, which is machine learning, but couldn't install.
Speaker A: It because there's so many pieces involved.
Speaker B: So many dependencies, right?
Speaker A: Yeah.
Speaker B: So our use case of Conda was Conda install scikit learn. And it was the best way to install scikit learn in 2013 to really 2018 1718 pip finally caught up. I still think you should cond install psychit learners. What a pip install site learn. But you can pip install. I get learned. The issue is the package they created was wheels and pip does not handle the multi vendor, they don't handle the fact you have c libraries you're depending on, they just stop at the Python boundary. And so what you have to do in the wheel world is you have to vendor, you have to take all of the binary and vendor it. Now if your change happens in underlying dependency, you have to redo the whole wheel. So Tensorflow is a good example. You should not pip install tensorflow. It's a terrible idea. People do it because the popularity of pip, many people think, of course, that's how I install everything. Python.
Speaker A: Yeah, this is one of the big challenges. You know, you take a GitHub repository or just a basic blog post, the number of time pip is mentioned over Conda is like 100 x to one.
Speaker B: Correct. Correct.
Speaker A: So they just have to.
Speaker B: That was decreasing. It wasn't true early because Pip didn't exist. Like, Conda came first.
Speaker A: So. But that's like the long tail of the Internet documentation, user generated. So that I, like, you think, how do I install? You google, how do I install tensorflow? You're just not going to see Conda in that first page.
Speaker B: Correct. Exactly. And that today you would have in 2016, 2017.
Speaker A: And it's sad because you saw the condo solves a lot of usability issues.
Speaker B: Correct.
Speaker A: For especially super challenging things. I don't know, one of the big pain points for me was just on the computer vision side, OpenCV installation, that perfect example.
Speaker B: Yes.
Speaker A: I think. I don't know if Conda solved that.
Speaker B: Condom has an open CV package.
Speaker A: I don't know. I certainly know Pip has not solved. I mean, there's complexities there because.
Speaker B: Right.
Speaker A: I actually don't know. I should probably know a good answer for this. But, you know, if, if you compile OpenCV with certain dependencies, you'll be able to do certain things. So there's this kind of flexibility of what you like, what options you compile with. And I don't think it's trivial to do that with conda or with.
Speaker B: So Conda has a notion of variance of a package. You can actually have different compilation versions of a package. So not just the version is different, but. Oh, this is compiled with these optimizations on. So Khan does have an answer, has those flavors, has flavors, basically.
Speaker A: Well, Pip, as far as I know, does not have flavors.
Speaker B: No. Pip generally hasn't thought deeply about the binary dependency problem. Right. And that's why fundamentally it, it doesn't work for the Sci-Fi ecosystem. It barely, you can sort of paper over it and duct tape and it kind of works until it doesn't. It falls apart entirely. So it's been a mixed bag, like, and I've been having lots of conversations with people over the years because again, it's an area where if you, if you understand some things, but not all the things, but they've done a great job of community appeal. This is an area where I think anaconda, as a company, needed to do some things in order to make condom more community centric. And this is. I talk about this all the time. There's a balance between every project starts with what I call company backed open source. Even if the company is yourself, it's just one person doing business as. But ultimately, for products to succeed virally and become massive influencers, they have to get community people on board. They have to get other people on board. So it has to become community driven. And a big part of that is engagement with those people, empowering people, governance around it. And there was. And what happened with Conda in the early days, Pip emerged and we did do some good things. Conda Forage, Conda Forge community is sort of the community recipe creation community, but Conda itself, I still believe. And Peter is CEO of Anaconda. He's my co founder. I ran Anaconda till 2017, 2018.
Speaker A: Is Peter still an anaconda?
Speaker B: Peter still Anaconda. Right. And we're still great friends. We're great friends. We talk all the time. Love him to death. There's a long story there about why and how. And we can cover it in some other podcast, perhaps sort of more, maybe a more business focused one. But this is one area where I think Conda should be more community driven. He should be pushing more to get more community contributors to Conda and let the Anaconda shouldn't be fighting this battle. It's really a developers, like you said, help the developers and then they'll actually move us the right direction.
Speaker A: That was the problem I have is many of the cool kids I know don't use Conda. And that, to me, is confusing.
Speaker B: It is confusing. It's really a matter of. Condo has some challenges. First of all, Condo still needs to be improved. There's lots of improvements we made, and it's that aspect of, wait, who's doing this? And the fact that then the PI Pa really stepped up like they were not solving the problem at all. And now they kind of got to where they're solving it for the most part. And then effectively you could get, like, Conda solved a problem that was there. And it still does. And there's still great things it can do, and we still use it all the time at quant site and with other clients. But you can do similar things with Pip and Docker, especially with the web development community. Part of it, again, is there's a lot of different kind of developers in the python ecosystem, and there's still a lack of some clear understanding. I go to the Python conference all the time, and there's only a few people in the pipe ba who get it and then others who are just massively trumpeting the power of pit but just do not understand the problem.
Speaker A: Yeah. So one of the obvious things to me from a mom, from a non programmer perspective is the across operating system usability. That's much more natural. So there's windows and just, it seems much easier to recommend Conda there. But then you should also recommend it across the board. So I'll definitely sort of.
Speaker B: But what I recommend now is a hybridization. I do, I mean, I have no problem.
Speaker A: Is it possible to use it is.
Speaker B: It is what I like. Build the environment with Pip, with Conda. Build an environment with Conda and then pip install on top of that. That's fine. Be careful about PIp installing OpenCV or tensorflow or, because if somebody's allowed that, it's going to be most surely done in a way that can't be updated that easily.
Speaker A: So install like the big packages, the infrastructure, Conda, and then the weirdos, like the weird like implementation. For some I had, there's a cool library, I used that based on your location and time of day and date, tells you the exact position of the sun relative to the earth. And it's just like a simple library, but it's very precise. And I was like, all right, but that was in this pipe.
Speaker B: The thing they did really well is Python developers who want to get their stuff published, you have to have a Pip recipe, right? Even if it's the challenge is there's a key thing that needs to be added to PIp. Just simply add the PiP. The ability to defer to a system package manager because recognize you're not going to solve all the dependency problem. So let like give up and allow the system packager to work that way. Anaconda is installed and it has pip. It would default to Conda to install its stuff, but Red Hat RPM would default to RPM to install more things like that's the, that's a key. Not difficult, but somewhat where some work feature needs to be added. That's an example of something like, I know we need to root and do it. I mean, it's where I wish I had more money. I wish I was more successful in the business side trying to get there, but I wish my family, friends and fool community that I know was larger, was larger and had more money. Because I know tons of things to do effectively with more resources, but I have not yet been successful at channel tons of it. Some I'm happy with what we've done. We've created again at Quansite, what we created to get Anaconda started. We created Kubernetes analytics, get Anaconda started, done it again with quant site. Super excited by that, by the way. It took three years to do it.
Speaker A: What is quantite? What is its mission? We've talked a few times about different fascinating aspects of it, but let's big picture, what is big picture?
Speaker B: Quant site Quantite, its mission is to connect data to an open economy. So it's basically consulting of the PI data ecosystem. It's a consulting company. And what I've said when I started it was we're trying to create products, people and technology. So it's divided into two groups and a third one as well. The two groups are a consulting services company that just helps people do data science and data engineering and data management better and more efficient. Full stack, like full stack, full science, full thing. We'll help you build an infrastructure. If you're using Jupyter or you need. We do staff augmentation, need more programmers, help you use das more effectively, help use GPU's more effectively. Just basically a lot of people need help. So we do training as well to help people, both immediate help and then learn from somebody. We've added a bunch of stuff too. We've kind of separated some of these other things into another company called Open Teams that we currently started. One of the things I loved, what we did at Anaconda was creating a community innovation team. I want to replicate that. We did a lot of innovation in Anaconda. I wanted to do innovation, but also contribute to the projects that existed, like create a place where maintainers, so that Scipi and numpy and numpy. And all these projects we already started can pay people to work on them and keep them going. So that's labs. Quansite Labs is a separate organization. It's a nonprofit mission. The profits of Quantite help fund it. In fact, every project that we have at Quansite, a portion of the money goes directly to quant site labs to help keep it funded. So we've gotten several mechanisms. We keep quant site labs funded currently. So I'm really excited about labs because it's been a mission for a long time.
Speaker A: What kind of projects are within labs?
Speaker B: So Labs is working to make the software better, like make numpy better, make Sci-Fi better, make. It only works on open source, so, you know, if somebody wants to. So, you know, companies do. We have a thing called a community work order. We call it if a company says, I want to make spider better, okay, cool. You can pay for a month of a developer of spider or developer of numpy or developer of scipy. You can't tell them what you want them to do. You can give them your priorities and things you wish existed, and they'll work on those priorities with the community to get what the community wants and what emerges, what the community wants.
Speaker A: Is there some aspect on the consulting side that is helping, as we were talking about morphology and so on? Is there specific application that are particularly, like, driving? Sort of inspiring the need for updates to cyber?
Speaker B: Absolutely, absolutely. GPU's are absolutely one of them. And new hardware beyond GPU's, I mean, Tesla's dojo chip, I'm hoping we'll have a chance to work on that, perhaps. Things like that are definitely driving it. The other thing is driving is scalable, like speed and scale. How do I write numpy code or numpy litecode if I want it to run across a cluster? Oh, that's dask. Or maybe it's Ray. There's ways to do that now. Or there's Modin and there's so pandas code, numpy code, sci PI code, second learn code that I want to scale. So that's one big area.
Speaker A: Have you gotten a chance to chat with Andre and Elon about? Because, like.
Speaker B: No, I would love to, by the way. I have not, but I'd love to. I just saw their Tesla AI days video. Yeah, super excited.
Speaker A: So this one of the, you know, I love great engineering, software engineering teams and engineering teams in general, and they're doing a lot of incredible stuff with Python. They're like, they are revolutionizing so many aspects of the machine learning pipeline.
Speaker B: I agree.
Speaker A: That's operating in the real world, and so much of that is Python. Like you said, the guy running Andre Kapathi running autopilot is tweeting about optimization of numpy versus.
Speaker B: I would love to talk to him. In fact, we have at quantite, we've been fortunate enough to work with Facebook on Pytorch directly. So we have about 13 developers at Quansethe. Some of them are in labs working directly on Pytorch.
Speaker A: On Pytorch?
Speaker B: On Pytorch, right. So I basically started Quonset. I went to both Tensorflow and Pytorch and said, hey, I want to help connect what you're doing to the broader Sci-Fi ecosystem, because I see what you're doing. But we have this bigger mission that we want to make sure we don't lose energy here. And Facebook responded really positively, and I didn't get the same reaction.
Speaker A: Not yet, not yet, not yet. I love the folks tensorflow.
Speaker B: I really love the folks tensorflow, too. They're fantastic. I think it's the, to just how it integrates with their business. I mean, like I said, there's a lot of reasons, just the timing, the integration with their business, what they're looking for. They're probably looking for more users. And I was looking to kind of cut some development effort and they couldn't receive that as easily, I think. So I'm hoping, I'm really hopeful and love the people there.
Speaker A: What's the idea behind open teams?
Speaker B: So open teams? I'm super excited about open teams because it's one of the, I mentioned my idea for investing directly in open source. So that's a concept called ferrous. But one of the things when we started quansite, we knew we would do is we developed products and ideas and new companies might come out. At Anaconda, this was clear. Anaconda, we did so much innovation that five or six companies could have come out of that, and we just didn't structure it so they could. But in fact, they have. You look at dask. There's two companies coming out of dask. Bokeh could be a company. There's lots of companies that could exist off the work we did there. And so I thought, oh, here's a recipe for an incubation, a concept that we could actually spawn new companies and new innovations. And then the idea has always been, well, money they earn should come back to fund the open source project.
Speaker A: Got it.
Speaker B: So labs is, I think there should be a lot of things like quant site labs. I think this concept is one that scales. You could have a lot of open source research labs along the way. So in 2018, when the bigger idea came how to make open source investable, I said, oh, I need to create a venture. So we created a venture fund called Quonset initiate. At the same time, it's an angel fund, really. We started to learn that process. How do we actually do this? How do we get LP's? How do we actually go in this direction and build a fund? And I'm like, every venture fund should have an associated open source research lab, which is no reason our venture fund, the carried interest portion of it goes to the lab. It directly will fund the lab.
Speaker A: That's fascinating, by the way. So you use the power of the organic formation of teams in the open source community. And then like naturally that leads to a business that can make.
Speaker B: There are some. Yeah, correct.
Speaker A: And then it always maintains and loops back to the open source.
Speaker B: Loops back to open source, exactly. I mean, to me it's a natural fit. There's something, there's, there's absolutely a repeatable pattern there. And it's also beneficial because, oh, I have natural connections to the open source. If I have an open source research lab, like they'll always be out there talking to people. And so we've, we've had a chance to talk to a lot of early stage companies and we, and our fund focus on the early stage. So Quant site has the services, the lab, the fund. Right. In that process, a lot of stuff started to happen, like, oh, you know, we started to do recruiting and support and training and I was starting to build a bigger sales team and marketing team and people besides just developers. And one of the challenges with that is you end up with different cultural aspects. You know, developers, you know, there's a, in any company you go to, you kind of go, look, is this a business led company, a developer led company? Do they kind of coexist? Are they, what's the interface between them? There's always a bit of a tension there, like we were talking about before. What is the tension there with open teams? I thought, wait a minute, we can actually just create this concept of quant site plus labs. While it's specific to the PI data ecosystem, the concept is general for all open source. Open teams emerge as, oh, we can create a business development company for many, many quant sites, like thousands of quant sites. And it can be a marketplace to connect, essentially be the enterprise software company of the future. If you look at what enterprise software wants from the customer side. And during this journey I've had the chance to work and sell to lots of companies, Exxon and Shell and Davey Morgan bank of America, like the Fortune hundred, and talk to a lot of people in procurement and see what are they buying and why are they buying. So don't know everything. But I've learned a lot about, oh, what are they really looking for? And they're looking for solutions. They're constantly given products from, from enterprise software. Here's open source lead enterprise software. Now I buy it and then they have to stitch it together into a solution. Open source is fantastic for gluing those solutions together. So whereas they keep getting new platforms they're trying to buy. What most enterprises want is tools that they can customize, that are as inexpensive as they can, yeah.
Speaker A: You always want to maintain the connection to the open source because that's open.
Speaker B: Teams is about solving enterprise software problems.
Speaker A: Brilliant, brilliant idea, by the way, with a connect.
Speaker B: But we do it honoring the topology. We don't hire all the people. We are a network connecting the sales energy and the procurement energy. And we were on the business side, get the deals closed and then have a network of partners like Quant site and others who we hand the deals to actually do the work. And then we have to maintain, I feel like we have to maintain some level of quality control so that the client can rely on open teams to ensure their delivery. Here's a lead, go figure that out. But no, we're gonna make sure you get what you need. Right.
Speaker A: By the way, it's such a skill, and I don't know if I have the patience I ever will have the patience to talk to the business people or more specific. I mean, there's all kinds of flavors of business people or marketing people.
Speaker B: There's a challenge. I hear what you're saying, because I've had the same challenge.
Speaker A: Yeah.
Speaker B: And it's true, there's sometimes you think, okay, this is way overwrought.
Speaker A: Yeah. You have to become an adult. You have to. Because the companies have needs, they have ways to make, make money, and they also want to learn and grow. And yet it's your job to kind of educate them on the best way. Like the value of open source, for example.
Speaker B: Right. And I'm really grateful for all my experiences over the past 14 years, understanding that side of it and still learning for sure. But not just understanding from companies, but also dealing with marketing professionals and sales professionals and people that make a career out of that and understanding what they're thinking about and also understanding, well, let's make this better. Like we can really make a place like open teams. I see as the transmission layer between companies and open source communities producing enterprise software solutions. Eventually we want to. Today we're taking on SaaS and Matlab and tools that we know we can replace for folks. Really, anytime you have a software tool at an organization where you have to do a lot of customization to make it work for you, it's not, you're just buying this thing off the shelf and it works. It's like, okay, you buy the system and then you customize it a lot, usually with expensive consultants to actually make it work for you. All of those should be replaced by open source foundations with the same customer.
Speaker A: You're doing such important work, such important work in these giant organizations, they're doing exactly that, taking some proprietary software and hiring a huge team of consultants that customize it. And then that whole thing gets outdated quickly.
Speaker B: Correct.
Speaker A: I mean, that's brilliant. So the one solution to that is kind of what Tesla is doing, a little bit of which is basically build up a software engineering team. Build a team from scratch.
Speaker B: Build a team from scratch. And companies are doing it. Well, that's what they're doing right now. Yeah, that's okay.
Speaker A: And you're creating a topology for some of that.
Speaker B: Right. You just don't have to do it. That's not the only answer. Right. And so other companies can access this, be more flexible. We literally, that's really say open team is the future of enterprise software. We're still early. Like this idea just percolated over the past year as we've kind of grown quant site and realized the extensibility of it. It. We just finished our seed round to help get more salespeople and then push the messaging correctly. And there's lots of tools we're building to make this easier. We want to automate the processes. We feel like a lot of the power is the efficiency of the sales process. There's a lot of wasted energy in small teams and the sales energy to get into large companies and make a deal. There's a lot of money spent on that.
Speaker A: They're creating the tools and processes for that sales.
Speaker B: That's super seamless. So a single company can go, oh, I've got my contract with open teams, we've got a subscription, they can get, they can make that procurement seamless. And then the fact they have access to the entire open source ecosystem and we have a, you know, so we have a part of our work that's embracing open source ecosystems and making sure we're doing things useful for them or serving them, and then companies making sure they're getting solutions they care about and then figuring out which, which targets we have. You know, we're not taking on all of open source, all of enterprise software yet, but we're, well, this feels like the future.
Speaker A: The idea and the vision is brilliant. Can I ask you, why do you think Microsoft bought GitHub? And what do you think is the future of GitHub?
Speaker B: Great point. I thought it was a brilliant move. I think they did, because Microsoft has always had a developer centric culture. They always have. One of the things Microsoft's always done well is understand that their power as developers. Ballmer didn't necessarily make a good meme about how he approached that, but they're broadening that. I think that's why. Because they recognize GitHub is where developers are at. Right. And so, but do they have a.
Speaker A: Vision, like open teams type of situation? Right.
Speaker B: I think so.
Speaker A: Yet are they just basically throwing money at developers to show their support?
Speaker B: I think so.
Speaker A: Without a topology like you put it like a way to leverage that, like to give developers actual money, right?
Speaker B: I don't think so. I think they're still, it's an enterprise software company and they make a bunch of money, they make a bunch of games. They're a big company, they sell products. I think part of it is they know there's opportunity to make money from GitHub. There's definitely a business there to sell to developers or to sell to people using development. I think there's part of that. I think part of it is also there's, they had definitely wanted to recognize that you need a value open source to get great developers, which is an important concept that was emerging over the past ten years, that PI data. We were able to convince JPMorgan to support PI data because of that fact. Right. That was where the money for them putting a couple hundred thousand into supporting PI data for several conferences was. They want developers and they realized that developers want to participate in open source. So enterprise software folks don't always understand how their software gets used. Having spent a lot of time on the floors at JPMorgan, at, in Shell, at ExxonMobil, you see, oh, these companies have large development teams and then they're kind of dealing with what's being delivered to them. So I really feel kind of a privilege that I had a chance to learn some of these people and see what they're doing and even work alongside them as a consultant using open source and trying to think, how do we make this work inside of our large organization?
Speaker A: Some of it is actually for a large organization, some of it is messaging to the world that you care about developers and you're the cool, you care, for example, like a Ford, because I talked to them, the car companies, right? They, they want to attract, you know, you want to take on Tesla and Autopilot, you want to take that, right? And so what do you do there? You show that you're cool. Like you, you try to show off that you care about developers and they have a lot of trouble doing that. And like one way I think like Ford should have bought GitHub. They just to show off.
Speaker B: Yeah, yeah.
Speaker A: Like these old, old school company. And it's in a lot, a lot of different industries. There's probably different ways. It's probably an art to show that you care to developers and the developers. It's exactly what you said. For example, just spitballing here, but Ford or somebody like that could give $100 million to the development of numpy and literally look at the top most popular projects in Python on and just say, we're just gonna give money.
Speaker B: Right?
Speaker A: Like that's gonna immediately make you cool.
Speaker B: They could actually, yeah. And in fact we set up numfocus to make it easy. But the challenge was also you have to have some business development. Like it's a bit of a, it's a bit of a seeding problem, right. And you look at how I've talked to the folks at Linux foundation, know how they're doing it. I know how in starting Numfocus. Cause we had two babies in 2012, one was anaconda, one was numfocus. Right? Both important efforts, they had distinct journeys and super grateful that both existed and still grateful both exist. But there's different energies in getting donations as there is getting. This is important to my business. Like I'm selling something that I'm going to make money this way. If you can tie it, if you can tie the message to an ROI for the company, it becomes an effective, it's much more effective. Right. And there are rational arguments to make. I've tried to have conversations with marketing, especially marketing departments. Very early on it was clear to me that, oh, you could just take a fraction of your marketing budget and just spend it on open source development and you get better results from your marketing.
Speaker A: How did those. Can I. Sorry, I'm going to try not to go. What have you learned from the interaction with the marketing folks on that? Kind of, because you gave a great example of something that will obviously be much better investment in terms of marketing is supporting open source projects.
Speaker B: The challenge is not dissimilar from the challenge you have in academia. At the different colleges, knowledge gets very specific and very channeled. People get a lot of learning in the thing they know about. It's hard then to bridge that and to get them to think differently enough to have a sense that you might have something to offer. It's like, well, how do I implement that? What do I do with that? Which budget do I take from? Do I slow down my spend on Google Ads or my spend on Facebook ads? Or do I not hire a content creator instead? There's an operational aspect to that. You have to be the CMO or the CEO. You have to get the right level.
Speaker A: So you have to hire at a high position level. They care about this and they, or.
Speaker B: They won't know how because you can also do it very clumsily. Right. And I've seen, because you can, you absolutely have to honor and recognize the people you're going to and the fact that if you just throw money at them, it could actually create more problems.
Speaker A: Can I just say, this is not you saying, can I just. Because I just need, I need, I need to say this. I've been very surprised how often marketing people are terrible at marketing. I feel like the best marketing is doing something novel and unique that anticipates the future. It feels like so much of the marketing practice is like what they took in school or maybe they're studying for what was the best thing that was done in the past decade and they're just repeating that over and over as opposed to innovating, like taking the risk. To me, Mark, that's a great point. Is taking the big risk.
Speaker B: That's a great point.
Speaker A: Being the first one to risk.
Speaker B: Yeah. There's an aspect of data observation from that risk. Right. I think shared what they're doing already, but absolutely it's about, I think it's content. There's this whole world on content marketing that you could almost say, well, yeah, you can get inundated with stuff that's not relevant to you, whereas what you're saying would be highly relevant and highly useful and highly, highly beneficial.
Speaker A: Yeah, but it's risky. That's why there's a lot of innovative ways of doing that. Tas as an example of people that basically don't do marketing, they do marketing in a very, like, Elon hired a person who's just good at Twitter for running Tesla's Twitter account. I mean, that's exactly what you want to be doing. You want to be constantly innovating in.
Speaker B: Right. There's an aspect of telling, I mean, I've definitely seen people doing great work where you're not talking about it. Like, I would say that's actually a problem I have right now with Quant site labs. Quantite labs been doing amazing work, really excited about it. But we have not been talking about it enough. We haven't been.
Speaker A: And there's different ways to talk about it. There's different ways to, there's different channels through which to communicate. There's also like, I'll just throw some shade at companies I love. So for example, iRobot, I just had a conversation with them. They make roombas and I think I love, they're incredible robots, but like every time they do commerce, like advertisement, not advertisement, but like marketing type stuff, it just looks so corporate. And to me, the incredible. I may be wrong in the case of iRobot, I don't know. But to me, when you're talking about engineering systems, it's really nice to show off the magic of the engineering and the software and all the geniuses behind this product and the tinkering and the raw authenticity of what it takes to build that system versus the marketing people who want to have pretty people standing there all pretty with the robots moving perfectly. So to me there's some aspect, it's like speaking to the hackers. You have to throw some bones, some care towards the engineers, the developers, because there's some aspect, one, for the hiring, but two, there's an authenticity to that kind of communication that's really inspiring to the end user as well. If they know that brilliant people, the best in the world, are working at your company, they start to believe that that product that you're creating is really.
Speaker B: Interesting because your initial reaction would be, wait, there's different users here. Why would you do that to, you know, my wife bought a roomba, but she, and she loves developers, she loves me, but she doesn't care about that culture. So essentially what you said is actually the authenticity because everyone has a friend, everyone knows people. There's word of mouth. I mean, if you.
Speaker A: Word of mouth is so, so fun.
Speaker B: Yeah, exactly. Because I think it's the lack of that, that realization. There's this halo effect. Right. And also influences your general market.
Speaker A: I.
Speaker B: Interesting.
Speaker A: For some stupid reason, I do have a platform. And it seems that the reason I have a platform, many others like me, millions of others, is like the authenticity. And like we get excited naturally about stuff. Yeah, and like, I don't want to get excited about that irobot video because it's boring, it's marketing, it's corporate, as opposed to, I wanted to do some fun. This is, this is me. Like a shout out to irobot is they're not letting me get into the robot.
Speaker B: Yeah, well, there's an aspect of that could be benefiting from a, from a culture of modular modularity, like add ons, and that could actually dramatically help. You've seen that over history. I mean, Apple is an example of a company like that or the like. I can see, I can see what your point is, is that you have something that needs to be, it needs to be adopted broadly. The concept needs to be adopted broadly and if you want to go beyond this one device, you need to engage this community.
Speaker A: Yeah. And connecting to the open source, as you said, I got to ask you, you're a programmer, one of the most impactful programmers ever. You've led many programmers. You lead many programmers. What are some, from a programmer perspective? What makes a good programmer? What makes a productive programmer? Is there a device you can give to be a great programmer in this world?
Speaker B: Great, great question. And there are times in my life I'd probably answer this even better than I hope maybe give an answer today, because I thought about this numerous times, like right now. I've spent on so much time recently hiring salespeople that your mind is literally on something else. But I reflected on the past, and also I have some really, the only way I can do this, I have some really great programmers that I work with who lead the teams that they lead, and my goal is to inspire them and hopefully help them, encourage them and help them encourage with their team. I would say there's a number of things, a couple of things. One is curiosity. I think a programmer without curiosity is mundane. You'll lose interest, you won't do your best work. It's an affect. Have some curiosity about things. I think, two, don't try to do everything at once. Recognize that we're limited as humans, you're limited as a human. Each one of us are limited in different ways. We all have our different strengths and skills. So it's adapting the art of programming to your skills. One of the things that always works is to limit what you're trying to solve. If you're part of a team, usually maybe somebody else has put the architecture together and they've gotten given a portion for you. If you're young, if you're not part of a team, it's sort of breaking down the problem into smaller parts is essential for you to make progress. It's very easy to take on a big project and try to do it all at once, and you get lost and then you do it badly. So thinking about very concretely what you're doing, defining the inputs and outputs, defining what you want to get done, even just talking about that, writing down before you write code, just what are you trying to accomplish? Being very specific about it really, really helps. I think using other people's work, don't be afraid that somehow you should do it all like nobody does.
Speaker A: Stand on the shoulders and copy and paste some stack over copy and paste, stack overflow.
Speaker B: It's like, but, but don't just copy and paste this is particularly relevant in the era of Codex and the, you know, the auto generated code, which is essentially, I see, as an indexing of stack overflow.
Speaker A: Right, exactly. It's like search engine.
Speaker B: It's a search engine over stack overflow, basically. So it's not, I mean, we've had this for a while.
Speaker A: Yeah.
Speaker B: But really you want to cut and paste, but not blindly, like, absolutely, I've cut and paste to understand, but then you understand, oh, this is what this means. Oh, this is what it's doing. And as much as you can. So it's critical. That's where the curiosity comes in. If you're just blindly cutting and pasting, you're not going to understand. And so understand and then, you know, be. Be sensitive to hype cycles. Right. Every, every few, often there's always a. Oh, test driven development is the answer. Oh, object oriented is the answer. Oh, there's always an answer. Agile is the answer. Be cautious of jumping onto a hype cycle. Likely there's signal, there's a thing there that's actually valuable you can learn from, but it's almost certainly not the answer to everything you need.
Speaker A: What lessons do you draw from you? Having created numpy and scipi in service of answering the question of what it takes to be a great programmer and giving advice to people, how can you be the next person to create a Sci-Fi?
Speaker B: Yeah. So one is listen to. Listen to who? To people that have a problem, which is everybody. But listen and listen to many and try to then do. You're going to have to do an experiment. Do fall down. Don't be afraid to fall down. Don't be afraid. The first thing you do is probably going to suck. And that's okay. Right. It's honestly, I think iteration is the key to innovation and it's almost that psychological hesitation. We have to just iterate. Like, yeah, we know it's not great, but next time it'll be better. I mean, just keep learning and keep proving, keep improving. So it's an attitude and then it doesn't take intense concentration. Right. Good things don't happen. Just, it's not quite like TikTok or like Facebook. You can't scroll your way to good programming. Right. There are sincere hours of deep. Don't be afraid of the deep problem. Often people will run away from something because, oh, I can't solve this. And you might be right, but give it an hour. Give it a couple of hours and see. And just five minutes. Not going to give you that.
Speaker A: Was it lonely when you were building Saipa and numpy.
Speaker B: Hugely, yeah. Absolutely lonely in the sense of you had to have an inner drive. And that inner drive, for me always comes from. I have to see that this is right in some angle. I have to believe it, that this is the right approach, the right thing to do. With Scipi, it was like, oh yeah, the world needs libraries in Python. Clearly Python's popular enough, with enough influential people that to start, and it needs more libraries. So that is a good in of itself. Do that good. So find a good. Find a thing that you know is good and just, just work on it. So that has to happen, and it is. And you kind of have to have enough realization of your mission to be okay with the naysayer or the fact that not everybody joins you up front. In fact, one thing, I've talked to people a lot. I've seen a lot of projects come and some fail. Like, not everything I've done has actually worked perfectly. I've tried a bunch of stuff that, okay, that didn't really work, or this isn't working and why. But you see the patterns and one of the key things is because you can't even know for six months. I sail 18 months right now. If you're starting a new project, you got to give it a good 18 month run before you even know if the feedback's there. Like it's. You're not going to know in six months, you might have the perfect thing, but six months from now, it's still kind of still emerging. So give it time, because you're dealing with humans, and humans have an inertia energy that just doesn't change that quickly.
Speaker A: So let me ask a silly question. But, you know, like you said, you're focused on the sales side of things currently, but back when you were actively programming, maybe in the nineties, you talked about ids. What's your setup that you have that brings you joy? Keyboard, number of screens, Linux.
Speaker B: I do still like to program some. It's not as much as I used to. I have two projects I'm super interested in trying to find funding for. I'm trying to figure out teams for them, but I could talk about those. But what I. Yeah, what get. I'm an emacs guy.
Speaker A: Great. Thank the superior editor, everybody. I've got. I don't often delete tweets, but one of the tweets I deleted when I said emacs was better than Vim. And then the hate I got it is I was like, I'm walking away from this.
Speaker B: I do too. I don't push it.
Speaker A: I mean, I'm just joking of course.
Speaker B: Yeah, exactly. It's kind of like. But people do take the editor, they take it.
Speaker A: I did as your life it is. But there's something beautiful to me about emacs, but there's. For people that love him, there's something beautiful to them.
Speaker B: I mean, I do use vim for quick editing, like command line. If I send quick editing, I will still sometimes use it, but not much like it's simple, correct a single edit character.
Speaker A: So when you were developing Scipi, you were using emacs?
Speaker B: Yep, Sci-fi and umpire, all written on emacs on a Linux box and CV's and then SVN version control. Git came later. I love distributed branch stuff. I think Git is pretty complicated, but I love the concept and also of course GitHub and then GitLab make git definitely consumable, but that came later.
Speaker A: Did you ever touch Lisp at all? What were your emotional feelings about all the parentheses?
Speaker B: So great question. So I find myself appreciating lispenness today much more than I did early, because when I came to programming, I knew programming, but I was a domain expert. To me, the parentheses were in the way. It's like, wow, it just gets in the way of my thinking about what I'm doing. So why would I have all these? That was my initial reaction to it. Now, as I appreciate the structure that naturally maps to a logical thinking about a program, I can appreciate them and why you could create editors that make it not so problematic. Right? Honestly. So I actually have a much more appreciation of Lisp and things like closure. And there's Hive, which is a python lisp that compiles the python bytecode. I think it's challenging. Typically these languages are. I even saw a whole data science programming system in Lisp that somebody created, which is cool. But again, I think it's the lack of recognition of the fact that there exists what I call occasional programmers, people that are never going to be programmers for a living. They don't want to have all this cuteness in their head. They want just. It's why basic. Microsoft had the right idea with basic in terms of having that be the language of visual basic, the language of Excel and SQL server. They should have converted that to python ten years ago. World would be a better place if they had.
Speaker A: There's also, there's a beauty and a magic to the history behind a language and lisp. Some of the most interesting people in, in the history of computer science and artificial intelligence have used Lisp. So yes, you feel.
Speaker B: Well, especially that language. When you, when you have a language you can think in it.
Speaker A: Yeah.
Speaker B: And it helps you think about it.
Speaker A: And it attracts certain kinds of people that think a certain kind of way and then that's, that's there. Okay, so what about like small laptop with a tiny keyboard or is there like kind of, you know.
Speaker B: Good question. I've never gotten into the big, many screens, to be honest. I mean, and maybe it's because in my head I kind of just swap between windows. Partly because I guess I really can't process three screens at once anyway. I just am looking at one and I just flip, I flip an application open. So where it's really helpful is actually when I'm trying to here's data and I want to input it from here. That's the only time I really need another screen.
Speaker A: So now because you're both a developer, lead developers, but then there's also these businesses and their salespeople network working with.
Speaker B: Large companies, operations, people, hiring people, the whole thing.
Speaker A: Which operating system is your favorite still at this point? So Linux was the early days.
Speaker B: Yeah, I love Linux as a server side and it was early days. I had my own Linux desktop. I've been on Mac laptops for ten years now.
Speaker A: This is what leadership looks like as you switch to Mac. Okay, great.
Speaker B: Pretty much just the fact that I had to do PowerPoints, I had to do presentations and plug in. I just couldn't mess with plugging in laptops. It wouldn't project.
Speaker A: So you mentioned quantite labs and things like that. Can you give advice on how to hire great programmers and great people?
Speaker B: Yeah, I would say produce an open source project, get people contributing to it and hire those people.
Speaker A: Yeah, I mean you're doing it sort of. You may be perhaps a little, but that's probably 100% really good advice.
Speaker B: I find it hard to hire. I still find it hard to hire. Like in terms of. I don't think it's not hard to hire. If I've worked with somebody for a couple of weeks, but an hour or two of interviews I have no idea.
Speaker A: So that instinct, that radar of knowing if you're good or not, you found that you're still not able to.
Speaker B: It's really hard. I mean the resume can help, but again the resume is like a presentation of the things they want you to see, not the reality of. And there's also, you have to understand what you're hiring for. There are different stages and different kinds of skills. And so it isn't just a. One of the things I talk a lot about internally at my company is that the whole idea of measuring ourselves against a single axis is flawed because we're nothing. It's a multidimensional space. And how do you order a multimensional space? There isn't one ordering. So this whole idea you immediately have projected into a thing when you're talking about hiring or best or worst or better or not better. So what is the thing you're actually needing and you can hire for that? There is such a thing. Generally, I really value people who have the affect that care about open source. So in some cases they're affinity to open source is simply kind of a filter of an affect. However, I have found this interesting dichotomy between open source contributors and product creation. I don't know if it's fully true, but there does seem to be the more experience, the more effect somebody has to an open source community, the less ability to actually produce product that they have. But you also want to true too. The more product focused are. I find a lot of people, I've talked to a lot of people who produce really great products, and they're looking over the open source communities kind of wanting to participate and play, but they played here and they do a great job here. And then they don't necessarily have some of the same. I don't think that's entirely necessary. I think part of it is cultural how that's how they've emerged. Because one of the things the open source community is often lack is great product management. Like some product management energy.
Speaker A: That's brilliant. But you want both of those energies in a place together.
Speaker B: Yes, you really do. And so it's a lot of, it's creating these teams of people that have these needed skills and attributes that are hard. And so one of the big things I look for is somebody that fundamentally recognizes their need to learn. Like one of the values that we have and all of the things we do is learning. If somebody thinks they know it, a, they're gonna struggle.
Speaker A: And some of that is just, there's more basic things like humility, just being humble in the face of all the things you don't know. And that's step one of learning.
Speaker B: That's step one of learning, right. And you know, I've spent a lot of time learning, right. Other people spend a lot more time, but I've spent a lot of time learning. I went, I mean, my whole goal was get a PhD because I love school and I wanted to be a scientist. And then what I found is what's been written about elsewhere as well is the more I learned, the more I didn't know, the more I realized, man, I know about this, but this is such a tiny thing in the global scope of what I might want to know about. So I need to be listening a whole lot better than I am, just talking. That's changed a little bit, actually. My wife says that I used to be a better listener. Now that I have, I'm so full of all these ideas I want to do. She kind of says, you got to give people time to talk.
Speaker A: So you've succeeded on multiple dimensions. So one is the tenure track faculty, the other is just creating all these products, then building up the businesses, then working with businesses. Do you have advice for young people today, in high school, in college, of how to live a life as nonlinear and as successful as yours, a life that they could be proud of?
Speaker B: Well, that's a super compliment. I'm humbled by that, actually. I would say a life that can be proud of. Honestly, one thing I've said to people is, first, find people you love and care about them. Family matters to me a lot. And family means people you love and have committed to. So it can be whatever you mean by that, but you need to have a foundation, so find people you love and want to commit to and do that because it anchors you in a way that nothing else can. And then you find other things, and then kind of from out there, you find other kinds of things you can commit to, whether it's ideas or people or groups of people. So especially in high school, I would say, don't settle on what you think. You know, give yourself ten years to think about the world. Like, I see a lot of high school students who seem to know everything already. I think I did, too. I think it's maybe natural bit, but recognize that the things you care about, you might change your perspective over time. I certainly have. Over time, I was really passionate about one specific thing, and I was kind of softened. I was a big. I didn't like the Federal Reserve, right. And we could have a longer conversation about monetary policy and finances, but I'm a little more nuanced in my perspective at this point. But, you know, that's one area where you learn about something. I want to attack it. Build, don't destroy, build. So often the tendency is to not like something they want to go. Attack it, build something, build something to replace it, build up, attract people to your new thing, you'll get far better. You don't need to destroy something to build something else. So that's, I guess, generally. And then definitely let curiosity follow your curiosity. And don't just follow the money.
Speaker A: And all of that, like you said, is grounded in family, friendship, and ultimately love. Yes, which is a great way to end it. Travis, you're one of the most impactful people in the engineering, the computer science in the human world. So I truly appreciate everything you've done and I really appreciate that you would spend your valuable time with me. It was an honor.
Speaker B: It was a real pleasure for me. I appreciate that.
Speaker A: Thanks for listening to this conversation with Travis Oliphant. To support this podcast, please check out our sponsors in the description. And now let me leave you with something that in the programming world is called Hutchinson's law. Every sufficiently advanced lisp application will eventually be reimplemented in python. Thank you for listening and hope to see you next time.
