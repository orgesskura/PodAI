Transcription for James Gosling： Java, JVM, Emacs, and the Early Days of Computing ｜ Lex Fridman Podcast #126.mp3:
Full transcript: The following is a conversation with James Gosling, the founder and lead designer behind the Java programming language, which in many indices is the most popular programming language in the world, or is always at least in the top two or three. We only had a limited time for this conversation, but I'm sure we'll talk again several times in this podcast. Quick summary of the sponsors public goods, Betterhelp and ExpressVPN please check out these sponsors in the description to get a discount and to support this podcast. As a side note, let me say that Java is the language with which I first learned object oriented programming, and with it the art and science of software engineering. Also, early on in my undergraduate education, I took a course on concurrent programming with Java. Looking back at that time, before I fell in love with neural networks, the art of parallel computing was both algorithmically and philosophically fascinating to me. The concept of a computer in my mind before then was something that does one thing at a time. The idea that we could create an abstraction of parallelism, where you could do many things at the same time while still guaranteeing stability and correctness, was beautiful. While some folks in college took drugs to expand their mind, I took concurrent programming. If you enjoy this thing, subscribe on YouTube, review it with five stars on Apple Podcast, follow on Spotify, support on Patreon, or connect with me on Twitter ex freedman as usual, I'll do a few minutes of ads now and no ads in the middle. I try to make these interesting, but I do give you timestamps, so go ahead and skip. But please do check out the sponsors by clicking the links in the description. It's the best way to support this podcast. This show sponsored by public goods, the one stop shop for affordable, sustainable, healthy household products. I take their fish oil and use their toothbrush, for example. Their products often have a minimalist black and white design that I find to be just beautiful. Some people ask why I wear this black suit and tie. There's a simplicity to it that to me, focuses my mind on the most important bits of every moment of every day, pulling only at the thread of the essential in all that life has to throw at me. It's not about how I look, it's about how I feel. That's what design is to me, creating an inner conscious experience, not an external look. Anyway, public goods plants one tree for every order placed, which is kind of cool. Visit publicgoods.com lex or use code Lex at checkout to get $15 off your first order. This show is also sponsored by Better help spelled h e l p help. Check it out@betterhelp.com lex. They figure out what you need and match you with a licensed professional therapist in under 48 hours. I chat with the person on there and enjoy it. Of course. I also regularly talk to David Goggins these days, who is definitely not a licensed professional therapist, but he does help me meet his and my demons and become comfortable to exist in their presence. Everyone is different, but for me, I think suffering is essential for creation, but you can suffer beautifully in a way that doesn't destroy you. I think therapy can help in whatever form that therapy takes, and I do think that betterhelp is an option worth trying. They're easy, private, affordable, and available worldwide. You can communicate by text anytime, and schedule weekly audio and video sessions. Check it out@betterhelp.com lex this show is also sponsored by ExpressVPn. You can use it to unlock movies and shows that are only available in other countries. I did this recently with Star Discovery on UK Netflix, mostly because I wonder what it's like to live in London. I'm thinking of moving from Boston to a place where I can build the business I've always dreamed of building. London is probably not in the top three, but top ten for sure. The number one choice currently is Austin for many reasons that I'll probably speak to another time. San Francisco unfortunately dropped out from the number one spot, but is still in the running. If you have advice, let me know. Anyway, check out expressvpn. It lets you change your location to almost 100 countries, and it's super fast. Go to expressvpn.com legspod to get an extra three months of expressvpn for free. That's expressvpn.com, lexpod. And now here's my conversation with James Gosling. I've read somewhere that the square root. Of two is your favorite irrational number. I have no idea where that got started. Is there any truth to it? Is there anything in mathematics or numbers that you find beautiful? Oh, well, there's lots of things in math that's really beautiful. I used to consider myself really good at math, and these days, I consider myself really bad at math. I never really had a thing for the square root of two, but when I was a teenager, there was this book called the Dictionary of Curious and Interesting numbers, which for some reason I read through and damn near memorized the whole thing. And I started this weird habit of when I was, like, filling out checks, you know, or, you know, paying for things with credit cards I would want to make the. The receipt add up to an interesting number. Is there some numbers that stuck with you that just kind of make you feel good? They all have a story, and fortunately, I've actually mostly forgotten all of them. Are they so, like, 42? Well, yeah. I mean, 42 is pretty magical. And then the irrationals. I mean, but is there a square root of two story in there somewhere? How did the number get started? It's, like, the only number that has destroyed a religion. In which way? Well, the pathogorians, they believed that all numbers were perfect, and you could represent anything as a rational number. And in that time period, this proof came out that there was no rational fraction whose value was equal to the square root of two. And that means nothing in this world is perfect, not even mathematics. Well, it means that your definition of perfect was imperfect. Well, then there's the Gaedel incompleteness theorems in the 20th century that ruined it, once again for everybody. Yeah, although, although, although. Godel's theorem. You know, the lesson I take from Godel's theorem is not that, you know, there are things you can't know, which is fundamentally what it says, but, you know, people want black and white answers. They want true or false. But if you. If you allow a three state logic, that is true, false, or maybe then. Then life's good. I feel like there's a parallel to modern political discourse in there somewhere, but, yeah, let me. Let me ask. So, with your kind of early love or appreciation of the beauty of mathematics, do you see a parallel between that world and the world of programming? You know, programming is all about logical structure, understanding the patterns that come out of computation. Understanding sort of. I mean, it's often like, you know, the path through the graph of possibilities to find a short route. Meaning like, find a short program that gets the job done. Yeah, kind of thing, but. So then, on the topic of irrational numbers, do you see. Do you see programming? You just painted it so cleanly. It's a little. This trajectory to find, like, a nice little program. But do you see it as fundamentally messy? Maybe unlike mathematics, I don't think of it as. I mean. I mean, you know, you watch somebody who's good at math, do math, and, you know, often it's. It's fairly messy. Sometimes it's kind of magical. When I was a grad student, one of the students, his name was Jim Sachs, he had this reputation of being sort of a walking, talking human theorem proving machine. And if you were having a hard problem with something, you could just, like, accost him in the hall and say, jim. And he would do this funny thing where he would stand up straight. His eyes would kind of defocus. He'd go, just like something in today's movies. You could just. And then he'd straighten up and say. And log in and walk away. And you go, well, okay, so n login is the answer. How did he get there? By which time he's down the hallway somewhere. Yeah, he's just the oracle. The black box just gives you the answer. Yeah. Then you have to figure out the path from the question to the answer. I think in one of the videos I watched, you mentioned Don Knuth, well, at least recommending his, you know, his book is something people should read. Oh, yeah. But in terms of, you know, theoretical computer science, do you. Do you see something beautiful that has been inspiring to you? Speaking of n log n, in your work on programming languages, that's in the. In that whole world of algorithms and complexity and, you know, these kinds of more formal mathematical things, or did that not really stick with you in your programming life? It did stick pretty clearly for me because one of the things that I care about is being able to sort of look at a piece of code and be able to prove to myself that it works. And so, for example, I find that I'm at odds with many of the people around me over issues about, like how you lay out a piece of software. Right. So software engineers get really cranky about how they format the documents that are the programs, where they put new lines and where they put the braces, the braces and all the rest of that. And I tend to go for a style that's very dense. To minimize the white space. Yeah. Well, to maximize the amount that I can see at once. Right. So I like to be able to see a whole function and to understand what it does, rather than have to go scroll, scroll, scroll, and remember. Right, yeah, I'm with you on that. Yeah, that's. And people don't like that. Yeah. I've had multiple times when engineering teams have staged what was effectively an intervention, where they invite me to a meeting and everybody's arrived before me, and they sort of all look at me and say, james, about your coding style. I'm sort of an odd person to be programming because I don't think very well verbally. I am just naturally a slow reader. I'm what most people would call a visual thinker. So when you think about a program, what do you see? I see pictures of. Right. So when I look at a piece of code on a piece of paper, it very quickly gets transformed into a picture and, you know, it's almost like a piece of machinery with, you know, this connected to that and like these gears. Yeah, yeah, I see them more, more like that than I see the, the sort of verbal structure or the lexical structure of letters. So then when you look at the program, that's why you want to see it all in the same place. Then you can just map it to something visual. Yeah. Like it leaps off the page at me and. Yeah. What are the inputs? What are the outputs? What the heck is this thing doing? Getting a whole vision of it. Can we go back into your memory? Memory, long term memory access. What's the first program you've ever written? Oh, I have no idea what the first one was. I mean, I know the first machine that I learned to program on, what is. It was a pDP eight at the University of Calgary. Do you remember the specs? Oh, yeah. So the thing had four k of Ram. Nice. Twelve bit words. The clock rate was, it was about a third of a megahertz. Oh, so I didn't even get to the m. Okay. Yeah, yeah. So, you know, we're like 10,000 times faster these days. And was this kind of like a supercomputer, like a serious computer for. No, the PDP eight. I was the first thing that people were calling like mini computer. Got it. They were sort of inexpensive enough that a university lab could maybe afford to buy one. And was there timesharing, all that kind of stuff? There actually was a timesharing os for that, but it wasn't used really widely. The machine that I learned on was one that was kind of hidden in the back corner of the computer center. And it was, it was bought as a, as part of a project to do computer networking. But, you know, they didn't actually use it very much. It was mostly just kind of sitting there and it was kind of sitting there and I noticed it was just kind of sitting there. And so I started fooling around with it and nobody seemed to mind, so I just kept doing that. And it had a keyboard and like a monitor. Oh, this is way before monitors were common. So it was, it was literally a model 33 teletype. Okay. With a paper tape reader. Okay. So the user interface wasn't very good. Yeah, yeah, it was, it was the first computer ever built with integrated circuits. But by integrated circuits I mean that they would have like ten or twelve transistors on one piece of silicon. Nice. Not the ten or 12 billion that machines have today. So what did that, I mean, feel like if you remember those, I mean, did you have kind of inklings of the magic of exponential kind of improvement of Moore's law of the potential of the future that was at your fingertips kind of thing, or was it just a cool. Yeah, it was just a toy. You know, I had always liked building stuff, but one of the problems with building stuff is that you need to have parts. You know, you need to have pieces of wood or wire or switches or stuff like that. And those all cost money. And here you could build. You could build arbitrarily complicated things. And I didn't need any physical materials. It required no money. That's a good way to put programming. You're right. It's if you love building things. Yeah. Completely accessible, you don't need anything. And anybody from anywhere could just build something really cool. Yeah, yeah. If you've got access to a computer, you can. You can build all kinds of crazy stuff. And, you know, and when you were somebody like me who had like, really no money, and, I mean, I remember just lusting after being able to buy, like, a transistor. And when I would do sort of electronics kind of projects, they were mostly made done by, like, dumpster diving for trash, you know. And, you know, one of my big hauls was discarded relay racks from the back of the phone company switching center. Oh, nice. That was the big memorable treasure. Oh, yeah. Yeah, that was a. What do you use that for? I built a machine that played tic tac toe nice out of relays. Of course, the thing that was really hard was that all the relays required a specific voltage, but getting a power supply that would do that voltage was pretty hard. And since I had a bunch of trashed television sets, I had to sort of cobble together something that was wrong but worked. So I was actually running these relays at 300 volts, and none of the electrical connections were properly sealed off. Surprised you survived that period of your life. Oh, for so many reasons. For so many reasons. I mean, it's pretty common for teenage geeks to discover, oh, thermite, that's real easy to make. Yeah, well, I'm glad you did. But do you remember the. Do you remember what program in Calgary that you wrote? Anything that stands out and what language? Well, so mostly anything of any size was assembly code. And actually, before I learned assembly code, there was this programming language on the PDP eight called Focal five. And focal five was kind of like a really stripped down Fortran. And I remember building programs that did things like play blackjack or solitaire or for some reason or other, the things that I really liked were ones where they were just, like, plotting graphs. So something with, like, a function or a data, and then you plot it. Yeah, yeah, I did bunches of those things and went, ooh, pretty pictures. And so this would, like, print out again, no monitors. Right. So it was like, on a teletype. Yeah. So using something that's kind of like a typewriter and then using those to plot functions. So when, I apologize to romanticize things, but when did you first fall in love with programming? You know, what was the first programming language, like, as a serious, maybe software engineer, where you thought, this is a beautiful. I guess I never really thought of any particular language as being, like, beautiful because it was never really about the language for me. It was about what you could do with it. And, you know, even today, you know, people try to get me into arguments about particular forms of syntax for this or that, and I'm like, who cares? It's about what you can do. Nothing, not how you spell the word. And so back in those days, I learned, like, pl one and Fortran and COBOl. And by the time that people were willing to hire me to do stuff, it was mostly assembly code and PDP eight assembly code and Fortran code. And I control data assembly code for, like, the CDC 6400, which was an early, I guess, supercomputer, even though that supercomputer has less compute power than my phone by a lot. And that was mostly, like you said, Fortran World. That said, you've also showed appreciation for the greatest language ever that I think everyone agrees is Lisp. Well, Lisp is definitely on my list of the greatest ones that have existed. Is that number one? Or, I mean, are you. I mean, you know, the thing is that it's, I wouldn't put it number one. No. Is it the parentheses? What, um. What do you love? And what do you not love about Lisp? Um, well, I guess the number one thing to not love about it is so freaking many parentheses. Yeah. Um, on the, on the love thing is, you know, out of those tons of parentheses, you actually get an interesting language structure. And I've always thought that there was a friendlier version of Lisp hiding out there somewhere, but I've never really spent much time thinking about it, thinking about it. But up the food chain for me from Lisp is simula, which a very small number of people have ever used. But a lot of people, I think you had a huge influence right, on the programming. But in a simula. I apologize if I'm wrong on this, but is that one of the first functional languages or. No, no, it was, it was the first object oriented programming language. Got it. It's really where object oriented and languages sort of came together. And it was also the language where co routines first showed up as a part of the language so you could have a programming style that was, you could think of it as sort of multi threaded with a lot of parallelism. Really? There was ideas of parallelism in there. Yeah, yeah. So that was, that was back, you know. So the first stimulus spec was simula 67. Like 1967. Yeah. Wow. So it had co routines, which are almost threads. The thing about co routines is that they don't have true concurrency. So you can get away without really complex locking. You can't usably do coroutines on a the multicore machine. Or if you try to do core coroutines on the multicore machine, you don't actually get to use the multiple cores, either that or you, you know, because you start then having to get into the universe of, you know, semaphores and locks and things like that. But you know, in terms of the, the style of programming, you could write code and think of it as being multi threaded. The mental model was very much a multi threaded one, and all kinds of problems you could approach very differently. To return to the world of Lisp, for a brief moment at CMU, you wrote a version of emacs that I think was very impactful on the history of emacs. What was your motivation for doing so at that time? So that was in like 85 or 86. I had been using Unix for a few years and most of the editing was this tool called Ed, which was sort of an ancestor of Vi. Is a pretty good editor, not a good editor? Well, if what you're using, if your input device is a teletype, it's pretty good. It's certainly more humane than Tico, which was kind of the common thing in a lot of the Dec universe at the time. Tico spelled TK, is that the. No, Tico, teco, the text editor and corrector. Corrector. Wow, so many features. And the original Emacs came out as. So Emacs stands for editor Macros, and Tico had a way of writing macros. And so the original emacs from MIT sort of started out as a collection of macros for Tico. But then the sort of emacs style got popular originally at MIT, and then people did a few other implementations of emacs that were the code base was entirely different, but it was sort of the philosophical style of the original emacs. What was the philosophy of emacs, by the way? Were all the implementations always in C? No. And how does Lisp fit into the picture? No. So the very first emacs was written as a bunch of macros for the Tico text editor. Wow, that's so interesting. And the macro language for Tico was probably the most ridiculously obscure format. If you just look at a Tico program on a page, you think it was just random characters. It really looks like just line noise. It's kind of like latex or something. Way worse than latex. Way, way worse than latex. But if you use Tico a lot, which I did, Tico was completely optimized for touch typing at high speed. So there were no two character commands, or there were a few, but mostly they were just one character. So every character on the keyboard was a separate command. And actually every character on the keyboard we use usually two or three commands because you hit shift and control and all of those things. It's just a way of very tightly encoding it. And mostly what Emacs did was it made that visual. One way to think of Teco is use emacs with your eyes closed, where you have to maintain a mental model of sort of a mental image of your document. You have to go, okay, so the cursor is between the a and the e, and I want to exchange those. So I do these things. Right. So it almost, almost exactly the emacs command set. Well, it's roughly approximate, roughly the same as emacs command set, but using emacs with your eyes closed. So what emacs, part of what emacs added to the whole thing was being able to visually see what you were editing in a form that matched your document. And a lot of things changed in the command set because it was programmable, it was really flexible. You could add new commands for all kinds of things. Then people rewrote emacs multiple times in Lisp. There was one done at MIT for the Lisp machine. There was one done for multics. And one summer I got a summer job to work on the Pascal compiler for multics. And that was actually the first time I used Emacs. To write the compilers. You worked in compilers too? It's fascinating. Yeah, so I did a lot of work. I mean, I spent like a really intense three months working on this Pascal compiler, basically living in emacs. And it was the one written in Maclist by Bernie Greenberg. And I thought, wow, this is just a way better way to do editing. And then I got back to CMU where we had kind of one of everything and two of a bunch of things and four of a few things. Since I mostly worked in the Unix universe and Unix didn't have an emacs, I decided that I needed to fix that problem. So I wrote this implementation of emacs in C because at the time, C was really the only language that worked on, on Unix. On Unix. And you were comfortable with C as well at that point? Yeah, at that time I had done a lot of C coding. This was in like 86. And, you know, it was running well enough to be, for me to use it to edit itself within a month or two. And then it kind of took over the university and it spread outside. Yeah. And then it went outside the. And largely because Unix kind of took over the research community on the ARPANEt. And Emacs was kind of the best editor out there. It kind of took over. There was actually a brief period where I actually had login ids on every non military host on the ARPANET because people would say, oh, can we install this? And I'd like, well, yeah, but you'll need some help. The days when security wasn't. When nobody cared. Nobody cared. Yeah. Can I ask briefly, what were those early days of ARPANET and the Internet like? What was. I mean, did you. Again, sorry for the silly question, but could you have possibly imagined that the Internet would look like what it is today? You know, some of it is remarkably unchanged. So one of the things that I noticed really early on when I was at Carnegie Mellon was that a lot of social life became centered around the ARPANEt. So things like between email and text messaging, because text messaging was a part of the ARPANET really early on. There were no cell phones. But you're sitting at a terminal and. You'Re typing stuff, essentially email or like, what is. Well, just like a one line message. Right? So. Oh, cool. So like chat. Like chat. Yeah. Right. So it's like sending a one line message to somebody. Right. And so pretty much everything from, you know, arranging lunch to going out on dates, you know, it was all like driven by social media. Social media, right. In the, in the, in the eighties. Easier than phone calls. Yeah. You know, and my life had gotten to where, you know, I was, you know, living on social media, you know, from like the early mid eighties. And so when it sort of transformed into the Internet and social media explodes. I was kind of like, what's the big deal? It's just a scale thing, right? The scale thing is just astonishing. But the fundamentals, in some ways, the. Fundamentals have hardly changed, and the technologies behind the networking have changed significantly. The watershed moment of going from the ARpanet to the Internet, and then people starting to just scale and scale and scale. The scaling that happened in the early nineties and the way that so many vested interests fought the Internet. Oh, who, oh, interesting. What was the. Oh, because you can't really control the Internet. Yeah. Who fought the Internet? So fundamentally, the, you know, the cable tv companies and broadcasters and phone companies, you know, at the deepest fibers of their being, they hated the Internet. But it was often kind of a funny thing because, you know, so think of a cable company, right? Most of the employees of the cable company, their job is getting tv shows, movies, whatever, out to their customers. They view their business as serving their customers. But as you climb up the hierarchy in the cable companies, that view shifts, because really, the business of the cable companies had always been selling eyeballs to advertisers. Right. And that view of a cable company didn't really dawn on most people who worked at the cable companies. But I had various desktops with various cable companies where you could see in the stratified layers of the corporation that this view of the reason that you have cable tv is to capture eyeballs. You know, they're, they didn't see it that way. Well, so, so the people who, the most, the people who worked at the phone company are at the cable companies, their view was that their, their job was getting delightful content out to their customers, and their customers would pay for them. Would pay for that. Higher up. They viewed this as a way of attracting eyeballs to them. And then what they were really doing was selling the eyeballs that were glued to their content to the advertisers. To the advertisers, yeah. And so the Internet was a competition in that sense. Right. And they were. Right. Well, yeah. I mean, there was one proposal that we sent, one detailed proposal that we wrote up back at that sun in the early nineties that was essentially like, look, with Internet technologies, anybody can become provider of content. So you could be distributing home movies to your parents or your cousins or your, who are anywhere else. Right. So anybody can become a publisher. Wow, you were thinking about that already. Yeah, that was net Netflix. Yeah, that was, like, in the early nineties, and we thought, this would be great. You could, you know, and the kind of content we were thinking about at the time was like, you know, home movies, kids essays, you know, stuff from, like, grocery stores or, you know, you know, that the. Or a restaurant that they could actually, like, start sending information about out. And that's brilliant. And the reaction of the cable companies was like, fuck no, because then we're out of business. What is it about companies that because they could have just. They could have been ahead of that wave, they could have listened to that and they could have, they didn't see. A path to revenue? You know, there's somewhere in there there's a lesson for, like, big companies, right? Like, to listen, to try to anticipate the renegade, the out there, out of the box people like yourself in the early days writing proposals about what this could possibly be. Well, and that it wasn't. If you're in a position where you're making truckloads of money off of a particular business model, the whole thought of, like, you know, leaping the chasm, right? You know, you know, you can see, oh, new models that are more effective are emerging, right? So, like, digital cameras versus film cameras, you know, I mean, why take the leap? Why? Why take the leap? Because you're making so much money off of film. And in my past at sun, one of our big customers was Kodak, and I ended up interacting with folks from Kodak quite a lot. And they actually had a big digital camera research and digital imaging business or development group, and they knew that. You just look at the trend lines and you look at the emerging quality of these digital cameras and you can just plot it on a graph and it's like, sure, film is better today, but digital is improving like this. The lines are going to cross, and the point at which the lines cross is going to be a collapse in their business. And they could see that. They absolutely knew that. The problem is that up to the point where they hit the wall, they were making truckloads of money. And when they did the math, it never started to make sense for them to kind of lead the charge. And part of the issues for a lot of companies for this kind of stuff is that if you're going to leap over a chasm like that, Kodak going from film to digital, that's a transition that's going to take a while. We had fights like this with people over, like, smart carts, the smart cards. Fights were just ludicrous. But that's where visionary leadership comes in, right? Somebody needs to roll in and say, then take the leap. Well, it partly takes the leap, but it's also partly take the hit. Take the hit initially so you can draw the graphs you want that show that if we leap from here on our present trajectory, we're doing this and there's a cliff. If we force ourselves into a transition and we proactively do that, we can be on the next wave. But there will be a period when we're in a trough, and pretty much always there ends up being a trough as you leap the chasm. But the way that public companies work on this planet, they're reporting every quarter. And the one thing that a CEO must never do is take a big hit. Take a big hit over some quarter. And many of these transitions involve a big hit for a period of time, one, two, three quarters, you get some companies, and like Tesla and Amazon are really good examples of companies that take huge hits, but they have the luxury of being able to ignore the stock market for a little while. And that's not so true today, really. But in the early days of both of those companies, they both did this thing of, I don't care about the quarterly reports. I care about how many happy customers we have. Having as many happy customers as possible can often be an enemy of the bottom line. Yeah. So how do they make that work? I mean, Amazon operated in the negative for a long time. It's like investing into the future. Right? But. So Amazon and Google and Tesla and a lot of those had what amounted to patient money, often because there's like a charismatic central figure who has a really large block of stock and they can just make it. So. So on that topic, just maybe it's a small tangent, but you've gotten the chance to work with some pretty big leaders. What are your thoughts about on the Tesla side, Elon Musk, leadership. On the Amazon side, Jeff Bezos, all of these folks with large amounts of stock and vision in their company. I mean, they're founders, either complete founders or like, early on folks. And Amazon have taken a lot of leaps and that probably at the time, people would criticize as like, what is this bookstore thing? Why? Yeah, and Bezos had a vision and he had the ability to just follow it. Lots of people have visions, and the average vision is completely idiotic. And you crash and burn. The Silicon Valley crash and burn rate is pretty high, and they don't necessarily crash and burn because they were dumb ideas. But often it's just timing. Timing and luck. And you take companies like TESLA and really the original TESLA, sort of pre Elon was kind of doing sort of okay, but he just drove them. And because he had a really strong vision. He would make calls that were always, you know, or, well, mostly pretty good. I mean, the Model X was kind of a goofball thing to do, but. He did it boldly anyway. Like, there's so many people that just said, like, there's so many people that oppose them. On the falcon one door. Like, the doors, from the engineering perspective, those doors are ridiculous. It's like, yeah, they are a complete. Travesty, but they're exactly the symbol of what great leadership is, which is like, you have a vision and you just. Go, like, if you're GoNna do something stupid, make it really stupid. Yeah. And go all in. Yeah, yeah. And, you know, to Musk's credit, he's a really sharp guy. So going back in time a little bit to Steve Jobs, you know, Steve Jobs was a similar sort of character who had a strong vision and was really, really smart. And he wasn't smart about the technology parts of things, but he was really sharp about the sort of human relationship between. The relationship between humans and objects. But he was a jerk. Can we just linger on that a little bit? People say he's a jerk. Is that a feature or a bug? Well, that's the question. Right. So you take people like Steve, who was really hard on people. And so the question is, was he really, was he needlessly hard on people, or was he just making people reach to meet his vision? And you could kind of spin it either way. Well, the results tell a story. You know, he, through whatever jerk ways he had, he made people often do the best work of their life. Yeah, yeah. And that was absolutely true. And, you know, I interviewed with him several times, I did various negotiations with him, and even though kind of personally I liked him, I could never work for him. Why do you think? Can you put into words the kind of tension that you feel would be destructive as opposed to constructive? Oh, he'd yell at people. He'd call them names. And you don't like that? No, no, I don't think you need to do that. And I think, you know, there's pushing people to excel, and then there's too far. And I think he was on the wrong side of the line. And I've never worked for Musk. I know a number of people who have, many of them that have said, and it shows up in the press a lot, that musk is kind of that way. And one of the things that I sort of loathe about Silicon Valley these days is that a lot of the high flying successes are run by people who are complete jerks. But it seems like there's been become this. There's come this sort of mythology out of Steve Jobs that the reason that he succeeded was because he was super hard on people. And in a number of corners, people start going, oh, if I want to succeed, I need to be a real jerk. And that, for me, just does not compute. I know a lot of successful people who are not jerks, who are perfectly fine people, you know, they tend to not be in the public eye. The general public somehow lifts the jerks up into the hero status. Right. Well, because they do things that get them in the press, and, you know, the people who, you know, don't do the kind of things that spill into the press. Yeah. Just talked to Chris Ladner for the second time. He's a super nice guy, just an example of this kind of, kind of individual that's in the background. I feel like he's behind, like, a million technologies. But he also talked about the jerkiness of some of the folks. Yeah, yeah. And the fact that being a jerk has become your required style. But one thing I maybe want to ask on that is maybe to push back a little bit. So there's the jerk side, but there's also, if I were to criticize what I've seen in Silicon Valley, which is almost the resistance to working hard. So on the jerkiness side is so postive jobs and Elon kind of push people to work really hard to do, and it's a question whether it's possible to do that nicely. But one of the things that bothers me, maybe I'm just russian and just kind of romanticize the whole suffering thing, but I think working hard is essential for accomplishing anything interesting, like, really hard. And in the parlance of Silicon Valley, it's probably too hard. This idea of that you should work smart, not hard. Often, to me, sounds like you should be lazy, because, of course you want to be work smart. Of course you want to be maximally efficient, but in order to discover the efficient path, like we're talking about with the short programs. Yeah. Well, you know, the smart hard thing. Yeah. Isn't an either or. It's an and. It's an and. Yeah. Right. And, um, you know, the. The people who say you should work smart, not hard, they pretty much always fail. Yeah. Thank you. Right. I mean, that's. That's. That's just. Just a recipe for disaster. I mean, there are. There are counterexamples, but they're more people who benefited from luck. And you're saying yeah, exactly. Luck and timing, like you said, is often an essential thing. But you're saying, you know, you can be, you can push people to work hard and do incredible work without. Without being nasty. Yeah, without being nasty. I think Google is a good example of. The leadership of Google throughout its history has been a pretty good example of not being nasty, being kind. I mean, the twins, Larry and Sergey, are both pretty nice people. Sandra Buchaz, very nice. Yeah, yeah. And you know, it's a culture of people who work really, really hard. Let me ask maybe a little bit of a tense question. We're talking about emacs. It seems like you've done some incredible work. So outside of Java you've done some incredible work that didn't become as popular as it could have because of like licensing issues and open source and like. Issues is. What are your thoughts about that entire mess? Like, what's about open source now in retrospect, looking back about licensing, about open sourcing, do you think open source is a good thing, a bad thing? Do you have regrets? Do you have wisdom that you've learned from that whole experience? So in general, I'm a big fan of open source. The way that it can be used to build communities and promote the development of things and promote collaboration and all of that is really pretty grand. When open source turns into a religion that says all things must be open source, I get kind of weird about that because it's sort of like saying some versions of that end up saying that all software engineers must take a vow of poverty as though it's unethical. To have money to build a company. Right. And, you know, there's a slice of me that actually kind of buys into that because, you know, people who make billions of dollars off of like a patent and the patent came from like, you know, literally a stroke of lightning that hits you as you lie to half awake in bed. Yeah, that's lucky. Good for you. The way that, that sometimes sort of explodes into something that looks to me a lot like exploitation. You know, you see a lot of that in like the drug industry. You know, when, you know, when you've got a, got, got medications that cost, you know, cost you like $100 a day and it's like. No, yeah, so the, the interesting thing about the sort of open source, what bothers me is when something is not open source and because of that, it's a worse product. Yeah. So like, I mean, if I look at your just implementation of emacs, like that could have been the dominant implementation. Like, I use emacs. That's my main id. I apologize to the world, but I still love it. And you know, I could have been using your implementation of emacs. And why aren't I? So are you using the GNU emacs? I guess the default on Linux is that GNU. Yeah. And that, through a strange passage, started out as the one that I wrote. Exactly. So it still has. Well, part of that was because in the last couple of years of grad school, it became really clear to me that I was either going to be Mister Emax forever or I was going to graduate. I couldn't actually do both. Was that a hard decision? That's so interesting to think about you as a, like it's a different trajectory that could have happened. Yeah, that's fascinating. You know, and maybe, you know, I could be fabulously wealthy today if I had become Mister Emax and Emacs had mushroomed into a series of text processing applications and all kinds of stuff. And you know, I would have, you know, but I have a long history of financially suboptimal decisions because I didn't want that life. Right. You know, I went to grad school because I wanted to graduate and you know, being Mister Emax for a while was kind of fun. And then it kind of became not fun, not fun. And you know, when it was not fun and I was, you know, there was no way I could, you know, pay my rent. Right? Yeah. And I was like, okay, do I carry on as a grad student? As a, you know, you know, I had a research assistantship and I was sort of living off of that. And I was trying to do my, you know, I was doing all my ra work, all my radical, you know, being a grad student work and being Mister Emacs all at the same time. And I decided to pick one. And one of the things that I did at the time was I went around all the people I knew on the ARpAnEt who might be able to take over looking after emacs. Pretty much everybody said I got a day job. So I actually found two folks in a couple of folks in a garage in New Jersey, complete with a dog who were willing to take it over, but they were going to have to charge money. But my deal with them was that they would only that they would make it free for universities and schools and stuff. And they said, sure. And that upset some people. So you have some. Now, I don't know the full history of this, but I think it's kind of interesting you have some tension with Mister Richard Stallman over the, I mean, he kind of represents this kind of, like you mentioned, free software. Sort of. A dogmatic focus on all information must. Be free, must be free. So what, is there an interesting way to paint a picture of the disagreement you have with Richard through the years? My basic opposition is that when you say information must be free to a really extreme form, that turns into all people whose job is the production of everything from movies to software, they must all take a vow of poverty because information must be free. And that doesn't work for me. Right. And I don't want to be wildly rich. I am not wildly rich. Do. Okay. But I do, actually. You know, I've, you know, I can feed my children. Yeah, I totally agree with you. It does just make me sad that sometimes the closing of the source, for some reason that people that, like a bureaucracy, begins to build, and sometimes it doesn't, it hurts the product. Oh, absolutely. Absolutely. It's always sad. And there's, and there is a. There is a balance in there. There's a balance. And, you know, it's not hard over rapacious capitalism, and it's not hard over in the other direction. And, you know, a lot of the open source movement, they have been managing to find a path to actually making money. So doing things like service and support works for a lot of people. And there are some ways where it's kind of. Some of them are a little perverse. Right. So as a part of things like the Sarbanes Oxley act and various people's interpretations of all kinds of accounting principles, and this is kind of a worldwide thing. But if you've got a corporation that is depending on some piece of software, often various accounting and reporting standards, say, if you don't have a support contract on this thing that your business is depending on, then that's bad. If you've got a database, you need to pay for support. But there's a difference between the support contracts that the average open source database producer charges and what somebody who is truly rapacious, like oracle, charges. Yeah. So it's a balance, like you said. It is absolutely a balance. And there are a lot of different ways to make the math work out for everybody. And the very unbalanced sort of, you know, like the winner takes all thing that happens in so much of modern commerce, that just doesn't work for me either. I know you've talked about this in quite a few places, but you have created one of the most popular programming languages in the world. This is a programming language that I first learned about object oriented programming with, I think it's a programming language that a lot of people use in a lot of different places and millions of devices today, Java. So the absurd question, but can you tell the origin story of Java so. Long time ago at sun, in about 1990, there was a group of us who were kind of worried that there was stuff going on in the universe of computing that the computing industry was missing out on. And so a few of us started this project at sun that really got going. I mean, we started talking about it in 1990, and it really got going in 91, and it was all about what was happening in terms of computing hardware, processors and networking and all of that. That was outside of the computer industry. And that was everything from the early glimmers of cell phones that were happening then to you look at elevators and locomotives and process control systems in factories and all kinds of audio equipment and video equipment. They all had processors in them and they were all doing stuff with them. And it sort of felt like there was something going on there that we needed to understand. And so C and C was in the air already? Oh, no. C and C absolutely owned the universe at that time. Everything was written in c and C. So where was the hunch that there was a need for a revolution? Well, so the need for a revolution was not about the language. It was about. It was just as simple and vague as there are things happening out there. We need to understand them. We need to understand them. And so a few of us went on several somewhat epic road trips. Literal road trips. Literal road trips. It's like, get on an airplane, go to Japan, visit Toshiba and Sharp and Mitsubishi and Sony and all of these folks. And because we worked for sun, we had folks who were willing to give us introductions. We visited Samsung and a bunch of korean companies, and we went all over Europe. We went to places like Phillips and Siemens and Thompson. What did you see there? For me, one of the things that sort of leapt out was that they were doing all the usual computer things that people had been doing, like, 20 years before. The thing that really leapt out to me was that they were sort of reinventing computer networking, and they were making all the mistakes that people in the computer industry had made. And since I had been doing a lot of work in the networking area, we'd go and visit company x. They'd describe this networking thing that they were doing, and just without any thought, I could tell them the 25 things that were going to be complete disasters with that thing that they were doing. And I don't know whether that had any impact on any of them. But that particular story of sort of repeating the disasters of the computer science industry was there. And one of the things we thought was, well, maybe we could do something useful here with, like, bringing them forward somewhat. But also at the same time, we learned a bunch of things from these mostly consumer electronics companies. And high on the list was that they viewed their, like, relationship with the customer as sacred. They. They were never, ever willing to make trade offs between for safety. Right. So one of the things that had always made me nervous in the computer industry was that people were willing to make trade offs in reliability to get performance. They want faster, faster breaks a little more often because it's faster, maybe you run it a little hotter than you should. Or the one that always blew my mind was the way that the folks, Athenae at cray supercomputers got their division to be really fast, was that they did Newton Raphson approximations. And so the bottom several bits of a over b were essentially random numbers. What could possibly go wrong? What could go wrong, right. And, you know, just figuring out how to nail the bottom bit, how to make sure that, you know, if you put a piece of toast in a toaster, it's not going to kill the customer. It's not going to burst into flames and burn the house down. So those are, I guess those are the principles that were inspiring. But how did, from the days of Java is called oak because of a tree outside the window story that lots of people know. How did it become this incredible, like, powerful language? Well, so it was a bunch of things. So we, you know, after all that, we started, you know, the way that we decided that we could understand things better was by building a demo, building a prototype of something. Got it. So kind of because it was easy and fun, we decided to build a control system for some home electronics, tv, VCR, that kind of stuff. And as we were building it, we sort of discovered that there were some things about standard practice in C programming that were really getting in the way. And it wasn't exactly because we were writing all the C code and C code that we couldn't write it to do the right thing. But that one of the things that was weird in the group was that we had a guy who's, his sort of top level job was, he was a business guy. He was sort of an MBA kind of person, think about business plans and all of that. And there were a bunch of things that were kind of. And we would talk about things that were going wrong or things that were going wrong, things that were going right. And as we thought about, you know, things like the requirements for security and safety, some low level details, and see like naked pointers. Yeah. And, you know, so back in the early nineties, it was well understood that, you know, the number one source of like, security vulnerabilities, it's pointers, was just pointers, was just bugs. Yeah, right. And it was like, you know, 50, 60, 70% of all security vulnerabilities were bugs. And the vast majority of them were like buffer overflows. So you're like, we have to fix this. We have to make sure that this cannot happen. And that was kind of the original thing for me, was this cannot, this cannot continue. And one of the things I find really entertaining this year was, I forget which Rag published it, but there was this article that came out that was an examination, it was sort of the result of an examination of all the security vulnerabilities in chrome. And Chrome is like a giant piece of C code, and 60 or 70% of all the security vulnerabilities were stupid pointer tricks. And I thought, it's 30 years later and we're still there. Still there and we're still there. And, you know, that's one of those slap your forehead and, and just want a crime. Would you attribute, or is that too much of a simplification? But would you attribute the creation of Java to sea pointers? Obvious problem. Well, that was one of the trigger points, concurrency, you've mentioned concurrency was a big deal because when you're interacting with people, the last thing you ever want to see is the thing like waiting and issues about the software development process. When faults happen, can you recover from them? What can you do to make it easier to create and eliminate complex data structures? What can you do to fix one of the most common sea problems, which is storage leaks and its evil twin, the freed but still being used piece of memory. You free something and then you keep using it. Oh yeah. So when I was originally thinking about that, I was thinking about that in terms of, of safety and security issues. And one of the things I sort of came to believe came to understand was that it wasn't just about safety and security, but it was about developer velocity. And I got really religious about this because at that point I had spent an ungodly amount of my life hunting down mystery pointer bugs. And, you know, like two thirds of my time as a software developer was, you know, because the mystery pointer bugs tend to be the hardest to find because they tend to be very, very statistical. The ones that hurt, you know, they're, you know, they're like a one in a million chance and, but nevertheless create. An infinite amount of suffering. Right. Because when you're doing a billion operations a second, you know, one in a million chance means it's gonna happen. And so I got really religious about this thing about, you know, making it so that if something fails, it fails immediately and visibly. And one of the things that was a real attraction of Java to lots of development shops was that we get our code up and running twice as fast. You mean the entirety of the development process, debugging, all that kind of stuff? Yeah. So if you measure time from, you know, you first touch fingers to keyboard until you get your first demo out, not much different. But if you look from fingers touching keyboard to solid piece of software that you could release in production, it would be way faster. And I think what people don't often realize, there's, yeah, there's things that really slow you down. The hard to catch bugs probably is the thing that really slows down, that. Really slows things down. But also one of the things that you get out of object oriented programming is a strict methodology about what are the interfaces between things and being really clear about how parts relate to each other. And what that helps with is so many times what people do is they kind of like sneak around the side. So if you've built something and people are using it, and then you say, well, okay, you know, I built this thing, you use it this way, and then you change it in such a way that it still does what you said it does. It just does it a little bit different. But then you find out that somebody out there was sneaking around the side. They had sort of tunneled in a back door, and this person, their code broke. And because they were sneaking through a side door. And normally the attitude is dummy, but a lot of times you can't get away. You can't just slap their hand and tell them to not do that because it's some bank's account reconciliation system that some developer decided, oh, I'm lazy, you know, I'll just sneak through the back door. And because the language allows it, I mean, you can't even get mad at them. And so one of the things I did that on the one hand upset a bunch of people is that I made it so that you really couldn't go through backdoors, right. So the whole point of that was to say if you need, you know, if the interface here isn't right. The wrong way to deal with that is to go through a back door. The right way to deal with it is to walk up to the developer of this thing and say, change the interface, fix it. So it was kind of like a social engineering thing, and it's brilliant. And people ended up discovering that that really made a difference in terms of a bunch of this stuff. If you're just screwing around, writing your own class project scale stuff, a lot of this stuff isn't quite so important because you're both sides of the interface. But when you're building larger, more complex pieces of software that have a lot of people working on them, and especially when they span organizations, you know, having really clear, having clarity about how that gets structured saves your life. Yeah. And you know, especially, you know, there's so much software that is fundamentally untestable, you know, until you do the real thing. Right. It's better to write good code in the beginning as opposed to writing crappy code and then trying to fix it and trying to scramble and figure out and through testing, figure out where the bugs are. Yeah, it's like which shortcut caused that rocket to not get where it was needed to go. So I think one of the most beautiful ideas, philosophically and technically, is of a virtual machine, the java virtual machine. Again, apologize to romanticize things, but. How. Did the idea of the JVM come to be? How to you radical of an idea? It is, because it seems to me to be just a really interesting idea in the history of programming. So. And what is it? So the Java virtual machine, you can think of it in different ways because it was carefully designed to have different ways of viewing it. So one view of it that most people don't really realize is there is that you can view it as sort of an encoding of the abstract syntax tree in reverse polish notation. I don't know if that makes any sense at all. I could explain it, and that would blow all of our time. But the other way to think of it and the way that it ends up being explained is that it's like the instruction set of an abstract machine that's designed such that you can translate that abstract machine to a physical machine. And the reason that that's important. So if you wind back to the early nineties, when we were talking to all of these companies doing consumer electronics, and you talk to the purchasing people, there were interesting conversations with purchasing. So if you look at how these devices come together, they're sheet metal and gears and circuit boards and capacitors and resistors. And stuff. And everything you buy has multiple sources. So you can buy a capacitor from here, you can buy a capacitor from there, and you've got kind of a market so that you can actually get a decent price for a capacitor. But CPU's, and particularly in the early nineties, CPU's were all different and all proprietary. So if you use the chip from intel, you had to be an intel customer for the end of. Till the end of time, because if you wrote a bunch of software, you know, when you wrote software using whatever technique you wanted. And C was particularly bad about this because there was a lot of properties of the underlying machine that came through. So you were stuck. So the code you wrote, you were stuck to that particular machine, you were. Stuck to that particular machine, which meant that they couldn't decide, you know, intel is screwing us. I'll start buying chips from, you know, Bob's better chips. This drove the, like, the purchasing people absolutely insane that they were welded into this decision and they would have to make this decision before the first line of software was written. That's funny that you're talking about the purchasing piece. So that's one perspective, right? There's a lot of other perspectives that all probably hated this idea, right? But from a technical aspect, just like the creation of an abstraction layer that's agnostic to the underlying machine, from the perspective of the developer, I mean, that's brilliant, right? Well, so that's like across the spectrum of providers of chips. But then there's also the time thing, because as you went from one generation to the next generation to the next generation, they were all different, and you would often have to rewrite your software. Oh, you mean generations of machines of different kinds. One of the things that sucked about a year out of my life was when San went from the Motorola 6810 processor to the 68020 processor. Then they had a number of differences, and one of them hit us really hard. And I ended up being the point guy on the worst case of where the new instruction cache architecture hurt us. Well, okay, so, I mean, one of this idea. I mean, okay, so, yeah, you articulate a Yemenite really clear, fundamental problem in all of computing. But how, where do you get the guts to think we can actually solve this? You know, in our conversations with, you know, all these vendors, you know, these, these problems started to show up, and I kind of had this epiphany because it reminded me of a summer job that I had had in grad school. So back in grad school, my thesis advisor well, I had two thesis advisors for bizarre reasons. One of them was a guy named Raj Reddy. The other one was Bob Sproul. And Raj. I love Raj. I love both of them. But Raj is amazing. So the department had bought a bunch of early workstations from a company called Three Rivers Computer Company. And three Rivers Computer company was a bunch of electrical engineers who wanted to do as little software as possible. So they knew that they'd need to have, like, compilers and an OS and stuff like that, and they didn't want to do any of that. And they wanted to do that for as close to zero money as possible. So what they did was they built a machine whose instruction set was the. Was literally the byte code for UCSD, pascal, the P code. And so we had a bunch of software that was written for this machine. And for various reasons, the company wasn't doing terrifically well. We had all this software on these machines, and we wanted it to run on other machines, but principally the vAx. And so Raj asked me if I could come up with a way to port all of this software from the Perc machines to vaxes. And I think he, you know, what he had in mind was something that would translate from, like, Pascal to C or Pascal to. Actually, at those times, pretty much it was, you could translate to c or c, and if you didn't like translating to sea, you could translate to. See, there was, you know, it's like the Henry Ford, you know, any color you want, just as long as it's black. And I went, that's really hard. Fascinating. And I noticed that. And I was, like, looking at stuff, and I went, ooh, I bet I could rewrite the p code into vax assembly code. And I. And then I started to realize that, you know, there were some properties of p code that made that really easy. Some properties that made it really hard. So I ended up writing this thing that translated from. From P code on the three rivers perks into assembly code on the vax. And I actually got higher quality code than the C compiler. And so everything just got really fast. It was really easy. It was like, wow, I thought that was a sleazy hack because I was lazy. And in actual fact, it worked really well. And I tried to convince people that that was maybe a good thesis topic, and nobody was like, nah, really? That's. I mean, yeah, it's kind of a brilliant idea. Right. Maybe you didn't have the. You weren't able to articulate the big picture of it. Yeah. And I think, you know, that was a key part. But so then, you know, clock comes forward a few years, and it's like, we've got to be able to, you know, if they wanted to be able to switch from, you know, this weird microprocessor to that weird and totally different microprocessor. How do you do that? And I kind of went, oh, maybe by doing something kind of in the space of Pascal P code, I could do like multiple translators. And I spent some time thinking about that and thinking about what worked and what didn't work. When I did the, the p code to vax translator, and I talked to some of the folks who were involved in smalltalk, because smalltalk also did a byte code. And then I kind of went, yeah, I want to do that. And it had the other advantage, that you could either interpret it or compile it. And interpreters are usually easier to do, but not as fast as a compiler. So I figured, good, I can be lazy again. Sometimes I think that most of my good ideas are driven by laziness, and often I find that some of people's stupidest ideas are because they're insufficiently lazy. They just want to build something really complicated. It's like, it doesn't need to be that complicated. Yeah. And so, and so that's how that came out. And, you know, but that also turned into kind of a, you know, almost a religious position on my part, which was. Which got me in several other fights. So, like, like, one of the things that was a real difference was the way that arithmetic worked. You know, once upon a time, there were, you know, it wasn't always just two's complement arithmetic. There were some machines that had one's complement arithmetic, which was like almost anything built by CDC. And occasionally there were machines that were decimal arithmetic. And I was like, this is crazy. You know, pretty much to his complement, integer arithmetic has won. So just, let's just do that. Just do that. One of the other places where there was a lot of variability was in the way that floating point behaved, and that was causing people throughout the software industry much pain, because you couldn't do a numerical computing library that would work on CDC and then have it work on an IBM machine and work on a DEC machine. And as a part of that whole struggle, there had been this big body of work on floating point standards, and this thing emerged that came to be called IEEE 754, which is the floating point standard that pretty much has taken over the entire universe. And at the time I was doing Java, it had pretty much completed taking over the universe. There were still a few pockets of holdouts, but I was like, you know, it's important to be able to say what two plus two means. Yeah. And so I went that, and one of the ways that I got into fights with people was that there were a few machines that did not implement Ieee 754 correctly. Well, of course, that's all short term kind of fights. I think in the long term, I think this vision is one out. Yeah. And I think it's, you know, and it worked out over time. I mean, the biggest fights were with intel because they had done some strange things with rounding. They'd done some strange things with their transcendental functions, which turned into a mushroom cloud of, you know, weirdness. Yeah. In the name of optimization. But I. From the perspective of the developer, that's not good. Well, their issues with transcendental functions were just stupid. Okay. So there's not even a trade off. That's just. Absolutely. Yeah, they were, they were doing range reduction in for sine and cosine, using a slightly wrong value for PI. Got it. Ten minutes. So in the interest of time, two questions. So one about Android and one about life. So, one, I mean, we could talk for many more hours. I hope eventually we might talk again. But I got to ask you about Android and the use of Java there, because it's one of the many places where Java just has a huge impact on this world. Just on your opinion, is there things that make you happy about the way Java is used in the Android world, and are there things that you wish were different? I don't know how to do a short answer to that, but I have to do a short answer to that, so I'm happy that they did it. Java had been running on cell phones at that time for quite a few years, and it worked really, really well. There were things about how they did it and in particular, various ways that they kind of violated all kinds of contracts. The guy who led it, Andy Rubin, he crossed a lot of lines. There's some lines crossed, yeah, lines were. Crossed that have since mushroomed into giant court cases and, you know, they didn't need to do that. And in fact, it would have been so much cheaper for them to not cross lines. I mean, I suppose they didn't anticipate the success of this whole endeavor, or do you think at that time it was already clear that this is going to blow up? I guess I sort of came to believe that it didn't matter what. And he did. It was going to blow up. Okay. He's, you know, I kind of started to think of him as like a manufacturer of bombs. Yeah. Some of the best things in this world come about. They're a little bit of explosive. Well, and some of the worst and. Some of the worst. Beautifully put. But is there? And like you said, I mean, does that make you proud that the java is in. Yeah, is in millions. I mean, it could be billions of devices and. Yeah, well, I mean, it was in billions of phones before Android came along. And, you know, I'm just as proud as, you know, of the way that, like, the, the smart card standards adopted Java and they did it. They, you know, everybody involved in that did a really good job. And that's, you know, billions and billions. That's crazy. The sim cards, you know, the sim cards in your pocket. Yeah, I mean, it's, I've been outside. Of that world for a decade, so I don't know how that has evolved, but, you know, it's just been crazy. So on that topic, let me ask again. There's a million technical things we could talk about, but let me ask the absurd, the old philosophical question about life. What do you hope when you look back at your life and people talk about you, write about you 500 years from now, what do you hope your legacy is? People not being afraid to take a leap of faith. I mean, I've got this kind of weird history of doing weird stuff. It worked out pretty damn well. It worked out right. And I think some of the weirder stuff that I've done has been the coolest and some of it crashed and burned and. Yeah, you know, I think well over half of the stuff that I've done is crashed and burned, which has occasionally been really annoying, but still you kept doing it. But yeah, yeah, yeah. And, you know, there, you know, even when things crash and burn, you at least learn something from, by way of advice. You know, people, developers, engineers, scientists, or just people who are young to look up to you. What advice would you give them? How to approach their life. Don't be afraid of risk. It's okay to do stupid things once, maybe a couple times, you know, you get a pass on the first time or two that you do something stupid, you know, the third or fourth time. Yeah, not so much. But also, you know, I don't know why, but really early on I started to think about ethical choices in my life. And because I a big science fiction fan, I got to thinking about just about every technical decision I make in terms of how do you want, are you building Blade Runner or Star Trek? Which one's better. Which future would you rather live in? So what's the answer to that? I would sure rather live in the universe of Star Trek. Star Trek. Yeah. That opens up a whole topic about AI, but that's a really interesting. Yeah, yeah, yeah. It's a really interesting idea. So your favorite AI system would be data from Star Trek, as my least. Favorite would easily be Skynet. Yeah. Beautifully put. I don't think there's a better way to end it. James, I can't say enough how much of an honor it is to meet you, to talk to you. Thanks so much for wasting your time with me today. Not a waste at all. Thanks, James. All right, thanks. Thanks for listening to this conversation with James Gosling. And thank you to our sponsors, public goods betterhelp, and express VPN. Please check out these sponsors in the description to get a discount and to support this podcast. If you enjoy this thing, subscribe on YouTube, review it with five stars on Apple Podcast, follow on Spotify, support on Patreon, or connect with me on Twitter exfriedmande. And now, let me leave you with some words from James Gosling. One of the toughest things about life is making choices. Thank you for listening and hope to see you next time.

Utterances:
Speaker A: The following is a conversation with James Gosling, the founder and lead designer behind the Java programming language, which in many indices is the most popular programming language in the world, or is always at least in the top two or three. We only had a limited time for this conversation, but I'm sure we'll talk again several times in this podcast. Quick summary of the sponsors public goods, Betterhelp and ExpressVPN please check out these sponsors in the description to get a discount and to support this podcast. As a side note, let me say that Java is the language with which I first learned object oriented programming, and with it the art and science of software engineering. Also, early on in my undergraduate education, I took a course on concurrent programming with Java. Looking back at that time, before I fell in love with neural networks, the art of parallel computing was both algorithmically and philosophically fascinating to me. The concept of a computer in my mind before then was something that does one thing at a time. The idea that we could create an abstraction of parallelism, where you could do many things at the same time while still guaranteeing stability and correctness, was beautiful. While some folks in college took drugs to expand their mind, I took concurrent programming. If you enjoy this thing, subscribe on YouTube, review it with five stars on Apple Podcast, follow on Spotify, support on Patreon, or connect with me on Twitter ex freedman as usual, I'll do a few minutes of ads now and no ads in the middle. I try to make these interesting, but I do give you timestamps, so go ahead and skip. But please do check out the sponsors by clicking the links in the description. It's the best way to support this podcast. This show sponsored by public goods, the one stop shop for affordable, sustainable, healthy household products. I take their fish oil and use their toothbrush, for example. Their products often have a minimalist black and white design that I find to be just beautiful. Some people ask why I wear this black suit and tie. There's a simplicity to it that to me, focuses my mind on the most important bits of every moment of every day, pulling only at the thread of the essential in all that life has to throw at me. It's not about how I look, it's about how I feel. That's what design is to me, creating an inner conscious experience, not an external look. Anyway, public goods plants one tree for every order placed, which is kind of cool. Visit publicgoods.com lex or use code Lex at checkout to get $15 off your first order. This show is also sponsored by Better help spelled h e l p help. Check it out@betterhelp.com lex. They figure out what you need and match you with a licensed professional therapist in under 48 hours. I chat with the person on there and enjoy it. Of course. I also regularly talk to David Goggins these days, who is definitely not a licensed professional therapist, but he does help me meet his and my demons and become comfortable to exist in their presence. Everyone is different, but for me, I think suffering is essential for creation, but you can suffer beautifully in a way that doesn't destroy you. I think therapy can help in whatever form that therapy takes, and I do think that betterhelp is an option worth trying. They're easy, private, affordable, and available worldwide. You can communicate by text anytime, and schedule weekly audio and video sessions. Check it out@betterhelp.com lex this show is also sponsored by ExpressVPn. You can use it to unlock movies and shows that are only available in other countries. I did this recently with Star Discovery on UK Netflix, mostly because I wonder what it's like to live in London. I'm thinking of moving from Boston to a place where I can build the business I've always dreamed of building. London is probably not in the top three, but top ten for sure. The number one choice currently is Austin for many reasons that I'll probably speak to another time. San Francisco unfortunately dropped out from the number one spot, but is still in the running. If you have advice, let me know. Anyway, check out expressvpn. It lets you change your location to almost 100 countries, and it's super fast. Go to expressvpn.com legspod to get an extra three months of expressvpn for free. That's expressvpn.com, lexpod. And now here's my conversation with James Gosling.
Speaker B: I've read somewhere that the square root.
Speaker A: Of two is your favorite irrational number.
Speaker C: I have no idea where that got started.
Speaker B: Is there any truth to it? Is there anything in mathematics or numbers that you find beautiful?
Speaker C: Oh, well, there's lots of things in math that's really beautiful. I used to consider myself really good at math, and these days, I consider myself really bad at math. I never really had a thing for the square root of two, but when I was a teenager, there was this book called the Dictionary of Curious and Interesting numbers, which for some reason I read through and damn near memorized the whole thing. And I started this weird habit of when I was, like, filling out checks, you know, or, you know, paying for things with credit cards I would want to make the. The receipt add up to an interesting number.
Speaker B: Is there some numbers that stuck with you that just kind of make you feel good?
Speaker C: They all have a story, and fortunately, I've actually mostly forgotten all of them.
Speaker B: Are they so, like, 42?
Speaker C: Well, yeah. I mean, 42 is pretty magical.
Speaker B: And then the irrationals. I mean, but is there a square root of two story in there somewhere? How did the number get started?
Speaker C: It's, like, the only number that has destroyed a religion.
Speaker B: In which way?
Speaker C: Well, the pathogorians, they believed that all numbers were perfect, and you could represent anything as a rational number. And in that time period, this proof came out that there was no rational fraction whose value was equal to the square root of two.
Speaker B: And that means nothing in this world is perfect, not even mathematics.
Speaker C: Well, it means that your definition of perfect was imperfect.
Speaker B: Well, then there's the Gaedel incompleteness theorems in the 20th century that ruined it, once again for everybody.
Speaker C: Yeah, although, although, although. Godel's theorem. You know, the lesson I take from Godel's theorem is not that, you know, there are things you can't know, which is fundamentally what it says, but, you know, people want black and white answers. They want true or false. But if you. If you allow a three state logic, that is true, false, or maybe then. Then life's good.
Speaker B: I feel like there's a parallel to modern political discourse in there somewhere, but, yeah, let me. Let me ask. So, with your kind of early love or appreciation of the beauty of mathematics, do you see a parallel between that world and the world of programming?
Speaker C: You know, programming is all about logical structure, understanding the patterns that come out of computation. Understanding sort of. I mean, it's often like, you know, the path through the graph of possibilities to find a short route.
Speaker B: Meaning like, find a short program that gets the job done. Yeah, kind of thing, but. So then, on the topic of irrational numbers, do you see. Do you see programming? You just painted it so cleanly. It's a little. This trajectory to find, like, a nice little program. But do you see it as fundamentally messy? Maybe unlike mathematics, I don't think of it as.
Speaker C: I mean. I mean, you know, you watch somebody who's good at math, do math, and, you know, often it's. It's fairly messy. Sometimes it's kind of magical. When I was a grad student, one of the students, his name was Jim Sachs, he had this reputation of being sort of a walking, talking human theorem proving machine. And if you were having a hard problem with something, you could just, like, accost him in the hall and say, jim. And he would do this funny thing where he would stand up straight. His eyes would kind of defocus. He'd go, just like something in today's movies. You could just. And then he'd straighten up and say. And log in and walk away. And you go, well, okay, so n login is the answer. How did he get there? By which time he's down the hallway somewhere.
Speaker B: Yeah, he's just the oracle. The black box just gives you the answer.
Speaker C: Yeah. Then you have to figure out the path from the question to the answer.
Speaker B: I think in one of the videos I watched, you mentioned Don Knuth, well, at least recommending his, you know, his book is something people should read.
Speaker C: Oh, yeah.
Speaker B: But in terms of, you know, theoretical computer science, do you. Do you see something beautiful that has been inspiring to you? Speaking of n log n, in your work on programming languages, that's in the. In that whole world of algorithms and complexity and, you know, these kinds of more formal mathematical things, or did that not really stick with you in your programming life?
Speaker C: It did stick pretty clearly for me because one of the things that I care about is being able to sort of look at a piece of code and be able to prove to myself that it works. And so, for example, I find that I'm at odds with many of the people around me over issues about, like how you lay out a piece of software. Right. So software engineers get really cranky about how they format the documents that are the programs, where they put new lines and where they put the braces, the braces and all the rest of that. And I tend to go for a style that's very dense.
Speaker B: To minimize the white space.
Speaker C: Yeah. Well, to maximize the amount that I can see at once. Right. So I like to be able to see a whole function and to understand what it does, rather than have to go scroll, scroll, scroll, and remember.
Speaker B: Right, yeah, I'm with you on that. Yeah, that's. And people don't like that.
Speaker C: Yeah. I've had multiple times when engineering teams have staged what was effectively an intervention, where they invite me to a meeting and everybody's arrived before me, and they sort of all look at me and say, james, about your coding style. I'm sort of an odd person to be programming because I don't think very well verbally. I am just naturally a slow reader. I'm what most people would call a visual thinker.
Speaker B: So when you think about a program, what do you see?
Speaker C: I see pictures of. Right. So when I look at a piece of code on a piece of paper, it very quickly gets transformed into a picture and, you know, it's almost like a piece of machinery with, you know, this connected to that and like these gears. Yeah, yeah, I see them more, more like that than I see the, the sort of verbal structure or the lexical structure of letters.
Speaker B: So then when you look at the program, that's why you want to see it all in the same place. Then you can just map it to something visual.
Speaker C: Yeah. Like it leaps off the page at me and.
Speaker B: Yeah. What are the inputs? What are the outputs? What the heck is this thing doing? Getting a whole vision of it. Can we go back into your memory? Memory, long term memory access. What's the first program you've ever written?
Speaker C: Oh, I have no idea what the first one was. I mean, I know the first machine that I learned to program on, what is. It was a pDP eight at the University of Calgary.
Speaker B: Do you remember the specs?
Speaker C: Oh, yeah. So the thing had four k of Ram.
Speaker B: Nice.
Speaker C: Twelve bit words. The clock rate was, it was about a third of a megahertz.
Speaker B: Oh, so I didn't even get to the m. Okay.
Speaker C: Yeah, yeah. So, you know, we're like 10,000 times faster these days.
Speaker B: And was this kind of like a supercomputer, like a serious computer for.
Speaker C: No, the PDP eight. I was the first thing that people were calling like mini computer.
Speaker B: Got it.
Speaker C: They were sort of inexpensive enough that a university lab could maybe afford to buy one.
Speaker B: And was there timesharing, all that kind of stuff?
Speaker C: There actually was a timesharing os for that, but it wasn't used really widely. The machine that I learned on was one that was kind of hidden in the back corner of the computer center. And it was, it was bought as a, as part of a project to do computer networking. But, you know, they didn't actually use it very much. It was mostly just kind of sitting there and it was kind of sitting there and I noticed it was just kind of sitting there. And so I started fooling around with it and nobody seemed to mind, so I just kept doing that.
Speaker B: And it had a keyboard and like a monitor.
Speaker C: Oh, this is way before monitors were common. So it was, it was literally a model 33 teletype.
Speaker B: Okay.
Speaker C: With a paper tape reader.
Speaker B: Okay. So the user interface wasn't very good.
Speaker C: Yeah, yeah, it was, it was the first computer ever built with integrated circuits. But by integrated circuits I mean that they would have like ten or twelve transistors on one piece of silicon.
Speaker B: Nice.
Speaker C: Not the ten or 12 billion that machines have today.
Speaker B: So what did that, I mean, feel like if you remember those, I mean, did you have kind of inklings of the magic of exponential kind of improvement of Moore's law of the potential of the future that was at your fingertips kind of thing, or was it just a cool.
Speaker C: Yeah, it was just a toy. You know, I had always liked building stuff, but one of the problems with building stuff is that you need to have parts. You know, you need to have pieces of wood or wire or switches or stuff like that. And those all cost money.
Speaker B: And here you could build.
Speaker C: You could build arbitrarily complicated things. And I didn't need any physical materials. It required no money.
Speaker B: That's a good way to put programming.
Speaker A: You're right.
Speaker B: It's if you love building things. Yeah. Completely accessible, you don't need anything. And anybody from anywhere could just build something really cool.
Speaker C: Yeah, yeah. If you've got access to a computer, you can. You can build all kinds of crazy stuff. And, you know, and when you were somebody like me who had like, really no money, and, I mean, I remember just lusting after being able to buy, like, a transistor. And when I would do sort of electronics kind of projects, they were mostly made done by, like, dumpster diving for trash, you know. And, you know, one of my big hauls was discarded relay racks from the back of the phone company switching center.
Speaker B: Oh, nice. That was the big memorable treasure.
Speaker C: Oh, yeah. Yeah, that was a.
Speaker B: What do you use that for?
Speaker C: I built a machine that played tic tac toe nice out of relays. Of course, the thing that was really hard was that all the relays required a specific voltage, but getting a power supply that would do that voltage was pretty hard. And since I had a bunch of trashed television sets, I had to sort of cobble together something that was wrong but worked. So I was actually running these relays at 300 volts, and none of the electrical connections were properly sealed off.
Speaker B: Surprised you survived that period of your life.
Speaker C: Oh, for so many reasons. For so many reasons. I mean, it's pretty common for teenage geeks to discover, oh, thermite, that's real easy to make.
Speaker B: Yeah, well, I'm glad you did. But do you remember the. Do you remember what program in Calgary that you wrote? Anything that stands out and what language?
Speaker C: Well, so mostly anything of any size was assembly code. And actually, before I learned assembly code, there was this programming language on the PDP eight called Focal five. And focal five was kind of like a really stripped down Fortran. And I remember building programs that did things like play blackjack or solitaire or for some reason or other, the things that I really liked were ones where they were just, like, plotting graphs.
Speaker B: So something with, like, a function or a data, and then you plot it.
Speaker C: Yeah, yeah, I did bunches of those things and went, ooh, pretty pictures.
Speaker B: And so this would, like, print out again, no monitors.
Speaker C: Right. So it was like, on a teletype.
Speaker B: Yeah.
Speaker C: So using something that's kind of like a typewriter and then using those to plot functions.
Speaker B: So when, I apologize to romanticize things, but when did you first fall in love with programming? You know, what was the first programming language, like, as a serious, maybe software engineer, where you thought, this is a beautiful.
Speaker C: I guess I never really thought of any particular language as being, like, beautiful because it was never really about the language for me. It was about what you could do with it. And, you know, even today, you know, people try to get me into arguments about particular forms of syntax for this or that, and I'm like, who cares? It's about what you can do. Nothing, not how you spell the word. And so back in those days, I learned, like, pl one and Fortran and COBOl. And by the time that people were willing to hire me to do stuff, it was mostly assembly code and PDP eight assembly code and Fortran code. And I control data assembly code for, like, the CDC 6400, which was an early, I guess, supercomputer, even though that supercomputer has less compute power than my phone by a lot.
Speaker B: And that was mostly, like you said, Fortran World. That said, you've also showed appreciation for the greatest language ever that I think everyone agrees is Lisp.
Speaker C: Well, Lisp is definitely on my list of the greatest ones that have existed.
Speaker B: Is that number one? Or, I mean, are you.
Speaker C: I mean, you know, the thing is that it's, I wouldn't put it number one. No.
Speaker B: Is it the parentheses? What, um. What do you love? And what do you not love about Lisp?
Speaker C: Um, well, I guess the number one thing to not love about it is so freaking many parentheses.
Speaker B: Yeah.
Speaker C: Um, on the, on the love thing is, you know, out of those tons of parentheses, you actually get an interesting language structure. And I've always thought that there was a friendlier version of Lisp hiding out there somewhere, but I've never really spent much time thinking about it, thinking about it. But up the food chain for me from Lisp is simula, which a very small number of people have ever used.
Speaker B: But a lot of people, I think you had a huge influence right, on the programming. But in a simula. I apologize if I'm wrong on this, but is that one of the first functional languages or.
Speaker C: No, no, it was, it was the first object oriented programming language.
Speaker B: Got it.
Speaker C: It's really where object oriented and languages sort of came together. And it was also the language where co routines first showed up as a part of the language so you could have a programming style that was, you could think of it as sort of multi threaded with a lot of parallelism. Really?
Speaker B: There was ideas of parallelism in there.
Speaker C: Yeah, yeah. So that was, that was back, you know. So the first stimulus spec was simula 67.
Speaker B: Like 1967.
Speaker C: Yeah.
Speaker B: Wow.
Speaker C: So it had co routines, which are almost threads. The thing about co routines is that they don't have true concurrency. So you can get away without really complex locking. You can't usably do coroutines on a the multicore machine. Or if you try to do core coroutines on the multicore machine, you don't actually get to use the multiple cores, either that or you, you know, because you start then having to get into the universe of, you know, semaphores and locks and things like that. But you know, in terms of the, the style of programming, you could write code and think of it as being multi threaded. The mental model was very much a multi threaded one, and all kinds of problems you could approach very differently.
Speaker B: To return to the world of Lisp, for a brief moment at CMU, you wrote a version of emacs that I think was very impactful on the history of emacs. What was your motivation for doing so at that time?
Speaker C: So that was in like 85 or 86. I had been using Unix for a few years and most of the editing was this tool called Ed, which was sort of an ancestor of Vi.
Speaker B: Is a pretty good editor, not a good editor?
Speaker C: Well, if what you're using, if your input device is a teletype, it's pretty good. It's certainly more humane than Tico, which was kind of the common thing in a lot of the Dec universe at the time.
Speaker B: Tico spelled TK, is that the.
Speaker C: No, Tico, teco, the text editor and corrector.
Speaker B: Corrector. Wow, so many features.
Speaker C: And the original Emacs came out as. So Emacs stands for editor Macros, and Tico had a way of writing macros. And so the original emacs from MIT sort of started out as a collection of macros for Tico. But then the sort of emacs style got popular originally at MIT, and then people did a few other implementations of emacs that were the code base was entirely different, but it was sort of the philosophical style of the original emacs.
Speaker B: What was the philosophy of emacs, by the way? Were all the implementations always in C?
Speaker C: No.
Speaker B: And how does Lisp fit into the picture?
Speaker C: No. So the very first emacs was written as a bunch of macros for the Tico text editor.
Speaker B: Wow, that's so interesting.
Speaker C: And the macro language for Tico was probably the most ridiculously obscure format. If you just look at a Tico program on a page, you think it was just random characters. It really looks like just line noise.
Speaker B: It's kind of like latex or something.
Speaker C: Way worse than latex. Way, way worse than latex. But if you use Tico a lot, which I did, Tico was completely optimized for touch typing at high speed. So there were no two character commands, or there were a few, but mostly they were just one character. So every character on the keyboard was a separate command. And actually every character on the keyboard we use usually two or three commands because you hit shift and control and all of those things. It's just a way of very tightly encoding it. And mostly what Emacs did was it made that visual. One way to think of Teco is use emacs with your eyes closed, where you have to maintain a mental model of sort of a mental image of your document. You have to go, okay, so the cursor is between the a and the e, and I want to exchange those. So I do these things. Right. So it almost, almost exactly the emacs command set. Well, it's roughly approximate, roughly the same as emacs command set, but using emacs with your eyes closed. So what emacs, part of what emacs added to the whole thing was being able to visually see what you were editing in a form that matched your document. And a lot of things changed in the command set because it was programmable, it was really flexible. You could add new commands for all kinds of things. Then people rewrote emacs multiple times in Lisp. There was one done at MIT for the Lisp machine. There was one done for multics. And one summer I got a summer job to work on the Pascal compiler for multics. And that was actually the first time I used Emacs.
Speaker B: To write the compilers. You worked in compilers too? It's fascinating.
Speaker C: Yeah, so I did a lot of work. I mean, I spent like a really intense three months working on this Pascal compiler, basically living in emacs. And it was the one written in Maclist by Bernie Greenberg. And I thought, wow, this is just a way better way to do editing. And then I got back to CMU where we had kind of one of everything and two of a bunch of things and four of a few things. Since I mostly worked in the Unix universe and Unix didn't have an emacs, I decided that I needed to fix that problem. So I wrote this implementation of emacs in C because at the time, C was really the only language that worked on, on Unix. On Unix.
Speaker B: And you were comfortable with C as well at that point?
Speaker C: Yeah, at that time I had done a lot of C coding. This was in like 86. And, you know, it was running well enough to be, for me to use it to edit itself within a month or two. And then it kind of took over the university and it spread outside. Yeah. And then it went outside the. And largely because Unix kind of took over the research community on the ARPANEt. And Emacs was kind of the best editor out there. It kind of took over. There was actually a brief period where I actually had login ids on every non military host on the ARPANET because people would say, oh, can we install this? And I'd like, well, yeah, but you'll need some help.
Speaker B: The days when security wasn't.
Speaker C: When nobody cared.
Speaker B: Nobody cared.
Speaker C: Yeah.
Speaker B: Can I ask briefly, what were those early days of ARPANET and the Internet like? What was. I mean, did you. Again, sorry for the silly question, but could you have possibly imagined that the Internet would look like what it is today?
Speaker C: You know, some of it is remarkably unchanged. So one of the things that I noticed really early on when I was at Carnegie Mellon was that a lot of social life became centered around the ARPANEt. So things like between email and text messaging, because text messaging was a part of the ARPANET really early on. There were no cell phones. But you're sitting at a terminal and.
Speaker B: You'Re typing stuff, essentially email or like, what is.
Speaker C: Well, just like a one line message. Right? So.
Speaker B: Oh, cool. So like chat.
Speaker C: Like chat.
Speaker B: Yeah.
Speaker C: Right. So it's like sending a one line message to somebody. Right. And so pretty much everything from, you know, arranging lunch to going out on dates, you know, it was all like driven by social media. Social media, right. In the, in the, in the eighties.
Speaker B: Easier than phone calls. Yeah.
Speaker C: You know, and my life had gotten to where, you know, I was, you know, living on social media, you know, from like the early mid eighties. And so when it sort of transformed into the Internet and social media explodes. I was kind of like, what's the big deal? It's just a scale thing, right? The scale thing is just astonishing.
Speaker B: But the fundamentals, in some ways, the.
Speaker C: Fundamentals have hardly changed, and the technologies behind the networking have changed significantly. The watershed moment of going from the ARpanet to the Internet, and then people starting to just scale and scale and scale. The scaling that happened in the early nineties and the way that so many vested interests fought the Internet.
Speaker B: Oh, who, oh, interesting. What was the. Oh, because you can't really control the Internet.
Speaker C: Yeah. Who fought the Internet? So fundamentally, the, you know, the cable tv companies and broadcasters and phone companies, you know, at the deepest fibers of their being, they hated the Internet. But it was often kind of a funny thing because, you know, so think of a cable company, right? Most of the employees of the cable company, their job is getting tv shows, movies, whatever, out to their customers. They view their business as serving their customers. But as you climb up the hierarchy in the cable companies, that view shifts, because really, the business of the cable companies had always been selling eyeballs to advertisers.
Speaker B: Right.
Speaker C: And that view of a cable company didn't really dawn on most people who worked at the cable companies. But I had various desktops with various cable companies where you could see in the stratified layers of the corporation that this view of the reason that you have cable tv is to capture eyeballs.
Speaker B: You know, they're, they didn't see it that way.
Speaker C: Well, so, so the people who, the most, the people who worked at the phone company are at the cable companies, their view was that their, their job was getting delightful content out to their customers, and their customers would pay for them. Would pay for that. Higher up. They viewed this as a way of attracting eyeballs to them. And then what they were really doing was selling the eyeballs that were glued to their content to the advertisers.
Speaker B: To the advertisers, yeah. And so the Internet was a competition in that sense.
Speaker C: Right. And they were.
Speaker B: Right.
Speaker C: Well, yeah. I mean, there was one proposal that we sent, one detailed proposal that we wrote up back at that sun in the early nineties that was essentially like, look, with Internet technologies, anybody can become provider of content. So you could be distributing home movies to your parents or your cousins or your, who are anywhere else. Right. So anybody can become a publisher.
Speaker B: Wow, you were thinking about that already. Yeah, that was net Netflix.
Speaker C: Yeah, that was, like, in the early nineties, and we thought, this would be great. You could, you know, and the kind of content we were thinking about at the time was like, you know, home movies, kids essays, you know, stuff from, like, grocery stores or, you know, you know, that the. Or a restaurant that they could actually, like, start sending information about out. And that's brilliant. And the reaction of the cable companies was like, fuck no, because then we're out of business.
Speaker B: What is it about companies that because they could have just. They could have been ahead of that wave, they could have listened to that and they could have, they didn't see.
Speaker C: A path to revenue?
Speaker B: You know, there's somewhere in there there's a lesson for, like, big companies, right? Like, to listen, to try to anticipate the renegade, the out there, out of the box people like yourself in the early days writing proposals about what this could possibly be.
Speaker C: Well, and that it wasn't. If you're in a position where you're making truckloads of money off of a particular business model, the whole thought of, like, you know, leaping the chasm, right? You know, you know, you can see, oh, new models that are more effective are emerging, right? So, like, digital cameras versus film cameras, you know, I mean, why take the leap? Why? Why take the leap? Because you're making so much money off of film. And in my past at sun, one of our big customers was Kodak, and I ended up interacting with folks from Kodak quite a lot. And they actually had a big digital camera research and digital imaging business or development group, and they knew that. You just look at the trend lines and you look at the emerging quality of these digital cameras and you can just plot it on a graph and it's like, sure, film is better today, but digital is improving like this. The lines are going to cross, and the point at which the lines cross is going to be a collapse in their business. And they could see that. They absolutely knew that. The problem is that up to the point where they hit the wall, they were making truckloads of money. And when they did the math, it never started to make sense for them to kind of lead the charge. And part of the issues for a lot of companies for this kind of stuff is that if you're going to leap over a chasm like that, Kodak going from film to digital, that's a transition that's going to take a while. We had fights like this with people over, like, smart carts, the smart cards. Fights were just ludicrous.
Speaker B: But that's where visionary leadership comes in, right? Somebody needs to roll in and say, then take the leap.
Speaker C: Well, it partly takes the leap, but it's also partly take the hit. Take the hit initially so you can draw the graphs you want that show that if we leap from here on our present trajectory, we're doing this and there's a cliff. If we force ourselves into a transition and we proactively do that, we can be on the next wave. But there will be a period when we're in a trough, and pretty much always there ends up being a trough as you leap the chasm. But the way that public companies work on this planet, they're reporting every quarter. And the one thing that a CEO must never do is take a big hit. Take a big hit over some quarter. And many of these transitions involve a big hit for a period of time, one, two, three quarters, you get some companies, and like Tesla and Amazon are really good examples of companies that take huge hits, but they have the luxury of being able to ignore the stock market for a little while. And that's not so true today, really. But in the early days of both of those companies, they both did this thing of, I don't care about the quarterly reports. I care about how many happy customers we have. Having as many happy customers as possible can often be an enemy of the bottom line.
Speaker B: Yeah. So how do they make that work? I mean, Amazon operated in the negative for a long time. It's like investing into the future.
Speaker C: Right? But. So Amazon and Google and Tesla and a lot of those had what amounted to patient money, often because there's like a charismatic central figure who has a really large block of stock and they can just make it. So.
Speaker B: So on that topic, just maybe it's a small tangent, but you've gotten the chance to work with some pretty big leaders. What are your thoughts about on the Tesla side, Elon Musk, leadership. On the Amazon side, Jeff Bezos, all of these folks with large amounts of stock and vision in their company. I mean, they're founders, either complete founders or like, early on folks. And Amazon have taken a lot of leaps and that probably at the time, people would criticize as like, what is this bookstore thing? Why?
Speaker C: Yeah, and Bezos had a vision and he had the ability to just follow it. Lots of people have visions, and the average vision is completely idiotic. And you crash and burn. The Silicon Valley crash and burn rate is pretty high, and they don't necessarily crash and burn because they were dumb ideas. But often it's just timing. Timing and luck. And you take companies like TESLA and really the original TESLA, sort of pre Elon was kind of doing sort of okay, but he just drove them. And because he had a really strong vision. He would make calls that were always, you know, or, well, mostly pretty good. I mean, the Model X was kind of a goofball thing to do, but.
Speaker B: He did it boldly anyway. Like, there's so many people that just said, like, there's so many people that oppose them. On the falcon one door. Like, the doors, from the engineering perspective, those doors are ridiculous.
Speaker C: It's like, yeah, they are a complete.
Speaker B: Travesty, but they're exactly the symbol of what great leadership is, which is like, you have a vision and you just.
Speaker C: Go, like, if you're GoNna do something stupid, make it really stupid. Yeah.
Speaker B: And go all in.
Speaker C: Yeah, yeah. And, you know, to Musk's credit, he's a really sharp guy. So going back in time a little bit to Steve Jobs, you know, Steve Jobs was a similar sort of character who had a strong vision and was really, really smart. And he wasn't smart about the technology parts of things, but he was really sharp about the sort of human relationship between. The relationship between humans and objects. But he was a jerk.
Speaker B: Can we just linger on that a little bit? People say he's a jerk. Is that a feature or a bug?
Speaker C: Well, that's the question. Right. So you take people like Steve, who was really hard on people. And so the question is, was he really, was he needlessly hard on people, or was he just making people reach to meet his vision? And you could kind of spin it either way.
Speaker B: Well, the results tell a story. You know, he, through whatever jerk ways he had, he made people often do the best work of their life.
Speaker C: Yeah, yeah. And that was absolutely true. And, you know, I interviewed with him several times, I did various negotiations with him, and even though kind of personally I liked him, I could never work for him.
Speaker B: Why do you think? Can you put into words the kind of tension that you feel would be destructive as opposed to constructive?
Speaker C: Oh, he'd yell at people. He'd call them names.
Speaker B: And you don't like that?
Speaker C: No, no, I don't think you need to do that. And I think, you know, there's pushing people to excel, and then there's too far. And I think he was on the wrong side of the line. And I've never worked for Musk. I know a number of people who have, many of them that have said, and it shows up in the press a lot, that musk is kind of that way. And one of the things that I sort of loathe about Silicon Valley these days is that a lot of the high flying successes are run by people who are complete jerks. But it seems like there's been become this. There's come this sort of mythology out of Steve Jobs that the reason that he succeeded was because he was super hard on people. And in a number of corners, people start going, oh, if I want to succeed, I need to be a real jerk. And that, for me, just does not compute. I know a lot of successful people who are not jerks, who are perfectly fine people, you know, they tend to not be in the public eye.
Speaker B: The general public somehow lifts the jerks up into the hero status.
Speaker C: Right. Well, because they do things that get them in the press, and, you know, the people who, you know, don't do the kind of things that spill into the press.
Speaker B: Yeah. Just talked to Chris Ladner for the second time. He's a super nice guy, just an example of this kind of, kind of individual that's in the background. I feel like he's behind, like, a million technologies. But he also talked about the jerkiness of some of the folks.
Speaker C: Yeah, yeah. And the fact that being a jerk has become your required style.
Speaker B: But one thing I maybe want to ask on that is maybe to push back a little bit. So there's the jerk side, but there's also, if I were to criticize what I've seen in Silicon Valley, which is almost the resistance to working hard. So on the jerkiness side is so postive jobs and Elon kind of push people to work really hard to do, and it's a question whether it's possible to do that nicely. But one of the things that bothers me, maybe I'm just russian and just kind of romanticize the whole suffering thing, but I think working hard is essential for accomplishing anything interesting, like, really hard. And in the parlance of Silicon Valley, it's probably too hard. This idea of that you should work smart, not hard. Often, to me, sounds like you should be lazy, because, of course you want to be work smart. Of course you want to be maximally efficient, but in order to discover the efficient path, like we're talking about with the short programs.
Speaker C: Yeah. Well, you know, the smart hard thing.
Speaker B: Yeah.
Speaker C: Isn't an either or. It's an and.
Speaker B: It's an and. Yeah.
Speaker C: Right. And, um, you know, the. The people who say you should work smart, not hard, they pretty much always fail.
Speaker B: Yeah. Thank you.
Speaker C: Right. I mean, that's. That's. That's just. Just a recipe for disaster. I mean, there are. There are counterexamples, but they're more people who benefited from luck.
Speaker B: And you're saying yeah, exactly. Luck and timing, like you said, is often an essential thing. But you're saying, you know, you can be, you can push people to work hard and do incredible work without.
Speaker C: Without being nasty.
Speaker B: Yeah, without being nasty. I think Google is a good example of. The leadership of Google throughout its history has been a pretty good example of not being nasty, being kind.
Speaker C: I mean, the twins, Larry and Sergey, are both pretty nice people.
Speaker B: Sandra Buchaz, very nice.
Speaker C: Yeah, yeah. And you know, it's a culture of people who work really, really hard.
Speaker B: Let me ask maybe a little bit of a tense question. We're talking about emacs. It seems like you've done some incredible work. So outside of Java you've done some incredible work that didn't become as popular as it could have because of like licensing issues and open source and like.
Speaker A: Issues is.
Speaker B: What are your thoughts about that entire mess? Like, what's about open source now in retrospect, looking back about licensing, about open sourcing, do you think open source is a good thing, a bad thing? Do you have regrets? Do you have wisdom that you've learned from that whole experience?
Speaker C: So in general, I'm a big fan of open source. The way that it can be used to build communities and promote the development of things and promote collaboration and all of that is really pretty grand. When open source turns into a religion that says all things must be open source, I get kind of weird about that because it's sort of like saying some versions of that end up saying that all software engineers must take a vow of poverty as though it's unethical.
Speaker B: To have money to build a company. Right.
Speaker C: And, you know, there's a slice of me that actually kind of buys into that because, you know, people who make billions of dollars off of like a patent and the patent came from like, you know, literally a stroke of lightning that hits you as you lie to half awake in bed. Yeah, that's lucky. Good for you. The way that, that sometimes sort of explodes into something that looks to me a lot like exploitation. You know, you see a lot of that in like the drug industry. You know, when, you know, when you've got a, got, got medications that cost, you know, cost you like $100 a day and it's like.
Speaker B: No, yeah, so the, the interesting thing about the sort of open source, what bothers me is when something is not open source and because of that, it's a worse product.
Speaker C: Yeah.
Speaker B: So like, I mean, if I look at your just implementation of emacs, like that could have been the dominant implementation. Like, I use emacs. That's my main id. I apologize to the world, but I still love it. And you know, I could have been using your implementation of emacs. And why aren't I?
Speaker C: So are you using the GNU emacs?
Speaker B: I guess the default on Linux is that GNU.
Speaker C: Yeah. And that, through a strange passage, started out as the one that I wrote.
Speaker B: Exactly. So it still has.
Speaker C: Well, part of that was because in the last couple of years of grad school, it became really clear to me that I was either going to be Mister Emax forever or I was going to graduate. I couldn't actually do both.
Speaker B: Was that a hard decision? That's so interesting to think about you as a, like it's a different trajectory that could have happened.
Speaker C: Yeah, that's fascinating. You know, and maybe, you know, I could be fabulously wealthy today if I had become Mister Emax and Emacs had mushroomed into a series of text processing applications and all kinds of stuff. And you know, I would have, you know, but I have a long history of financially suboptimal decisions because I didn't want that life. Right. You know, I went to grad school because I wanted to graduate and you know, being Mister Emax for a while was kind of fun. And then it kind of became not fun, not fun. And you know, when it was not fun and I was, you know, there was no way I could, you know, pay my rent. Right?
Speaker B: Yeah.
Speaker C: And I was like, okay, do I carry on as a grad student? As a, you know, you know, I had a research assistantship and I was sort of living off of that. And I was trying to do my, you know, I was doing all my ra work, all my radical, you know, being a grad student work and being Mister Emacs all at the same time. And I decided to pick one. And one of the things that I did at the time was I went around all the people I knew on the ARpAnEt who might be able to take over looking after emacs. Pretty much everybody said I got a day job. So I actually found two folks in a couple of folks in a garage in New Jersey, complete with a dog who were willing to take it over, but they were going to have to charge money. But my deal with them was that they would only that they would make it free for universities and schools and stuff. And they said, sure. And that upset some people.
Speaker B: So you have some. Now, I don't know the full history of this, but I think it's kind of interesting you have some tension with Mister Richard Stallman over the, I mean, he kind of represents this kind of, like you mentioned, free software.
Speaker A: Sort of.
Speaker C: A dogmatic focus on all information must.
Speaker B: Be free, must be free. So what, is there an interesting way to paint a picture of the disagreement you have with Richard through the years?
Speaker C: My basic opposition is that when you say information must be free to a really extreme form, that turns into all people whose job is the production of everything from movies to software, they must all take a vow of poverty because information must be free. And that doesn't work for me. Right. And I don't want to be wildly rich. I am not wildly rich. Do. Okay. But I do, actually. You know, I've, you know, I can feed my children.
Speaker B: Yeah, I totally agree with you. It does just make me sad that sometimes the closing of the source, for some reason that people that, like a bureaucracy, begins to build, and sometimes it doesn't, it hurts the product.
Speaker C: Oh, absolutely. Absolutely.
Speaker B: It's always sad.
Speaker C: And there's, and there is a. There is a balance in there.
Speaker B: There's a balance.
Speaker C: And, you know, it's not hard over rapacious capitalism, and it's not hard over in the other direction. And, you know, a lot of the open source movement, they have been managing to find a path to actually making money. So doing things like service and support works for a lot of people. And there are some ways where it's kind of. Some of them are a little perverse. Right. So as a part of things like the Sarbanes Oxley act and various people's interpretations of all kinds of accounting principles, and this is kind of a worldwide thing. But if you've got a corporation that is depending on some piece of software, often various accounting and reporting standards, say, if you don't have a support contract on this thing that your business is depending on, then that's bad. If you've got a database, you need to pay for support. But there's a difference between the support contracts that the average open source database producer charges and what somebody who is truly rapacious, like oracle, charges.
Speaker B: Yeah. So it's a balance, like you said.
Speaker C: It is absolutely a balance. And there are a lot of different ways to make the math work out for everybody. And the very unbalanced sort of, you know, like the winner takes all thing that happens in so much of modern commerce, that just doesn't work for me either.
Speaker B: I know you've talked about this in quite a few places, but you have created one of the most popular programming languages in the world. This is a programming language that I first learned about object oriented programming with, I think it's a programming language that a lot of people use in a lot of different places and millions of devices today, Java. So the absurd question, but can you tell the origin story of Java so.
Speaker C: Long time ago at sun, in about 1990, there was a group of us who were kind of worried that there was stuff going on in the universe of computing that the computing industry was missing out on. And so a few of us started this project at sun that really got going. I mean, we started talking about it in 1990, and it really got going in 91, and it was all about what was happening in terms of computing hardware, processors and networking and all of that. That was outside of the computer industry. And that was everything from the early glimmers of cell phones that were happening then to you look at elevators and locomotives and process control systems in factories and all kinds of audio equipment and video equipment. They all had processors in them and they were all doing stuff with them. And it sort of felt like there was something going on there that we needed to understand.
Speaker B: And so C and C was in the air already?
Speaker C: Oh, no. C and C absolutely owned the universe at that time. Everything was written in c and C.
Speaker B: So where was the hunch that there was a need for a revolution?
Speaker C: Well, so the need for a revolution was not about the language. It was about. It was just as simple and vague as there are things happening out there.
Speaker B: We need to understand them.
Speaker C: We need to understand them. And so a few of us went on several somewhat epic road trips.
Speaker B: Literal road trips.
Speaker C: Literal road trips. It's like, get on an airplane, go to Japan, visit Toshiba and Sharp and Mitsubishi and Sony and all of these folks. And because we worked for sun, we had folks who were willing to give us introductions. We visited Samsung and a bunch of korean companies, and we went all over Europe. We went to places like Phillips and Siemens and Thompson.
Speaker B: What did you see there?
Speaker C: For me, one of the things that sort of leapt out was that they were doing all the usual computer things that people had been doing, like, 20 years before. The thing that really leapt out to me was that they were sort of reinventing computer networking, and they were making all the mistakes that people in the computer industry had made. And since I had been doing a lot of work in the networking area, we'd go and visit company x. They'd describe this networking thing that they were doing, and just without any thought, I could tell them the 25 things that were going to be complete disasters with that thing that they were doing. And I don't know whether that had any impact on any of them. But that particular story of sort of repeating the disasters of the computer science industry was there. And one of the things we thought was, well, maybe we could do something useful here with, like, bringing them forward somewhat. But also at the same time, we learned a bunch of things from these mostly consumer electronics companies. And high on the list was that they viewed their, like, relationship with the customer as sacred. They. They were never, ever willing to make trade offs between for safety. Right. So one of the things that had always made me nervous in the computer industry was that people were willing to make trade offs in reliability to get performance. They want faster, faster breaks a little more often because it's faster, maybe you run it a little hotter than you should. Or the one that always blew my mind was the way that the folks, Athenae at cray supercomputers got their division to be really fast, was that they did Newton Raphson approximations. And so the bottom several bits of a over b were essentially random numbers.
Speaker B: What could possibly go wrong?
Speaker C: What could go wrong, right. And, you know, just figuring out how to nail the bottom bit, how to make sure that, you know, if you put a piece of toast in a toaster, it's not going to kill the customer. It's not going to burst into flames and burn the house down.
Speaker B: So those are, I guess those are the principles that were inspiring. But how did, from the days of Java is called oak because of a tree outside the window story that lots of people know. How did it become this incredible, like, powerful language?
Speaker C: Well, so it was a bunch of things. So we, you know, after all that, we started, you know, the way that we decided that we could understand things better was by building a demo, building a prototype of something.
Speaker B: Got it.
Speaker C: So kind of because it was easy and fun, we decided to build a control system for some home electronics, tv, VCR, that kind of stuff. And as we were building it, we sort of discovered that there were some things about standard practice in C programming that were really getting in the way. And it wasn't exactly because we were writing all the C code and C code that we couldn't write it to do the right thing. But that one of the things that was weird in the group was that we had a guy who's, his sort of top level job was, he was a business guy. He was sort of an MBA kind of person, think about business plans and all of that. And there were a bunch of things that were kind of. And we would talk about things that were going wrong or things that were going wrong, things that were going right. And as we thought about, you know, things like the requirements for security and safety, some low level details, and see like naked pointers.
Speaker B: Yeah.
Speaker C: And, you know, so back in the early nineties, it was well understood that, you know, the number one source of like, security vulnerabilities, it's pointers, was just pointers, was just bugs. Yeah, right. And it was like, you know, 50, 60, 70% of all security vulnerabilities were bugs. And the vast majority of them were like buffer overflows.
Speaker B: So you're like, we have to fix this.
Speaker C: We have to make sure that this cannot happen. And that was kind of the original thing for me, was this cannot, this cannot continue. And one of the things I find really entertaining this year was, I forget which Rag published it, but there was this article that came out that was an examination, it was sort of the result of an examination of all the security vulnerabilities in chrome. And Chrome is like a giant piece of C code, and 60 or 70% of all the security vulnerabilities were stupid pointer tricks. And I thought, it's 30 years later and we're still there. Still there and we're still there. And, you know, that's one of those slap your forehead and, and just want a crime.
Speaker B: Would you attribute, or is that too much of a simplification? But would you attribute the creation of Java to sea pointers? Obvious problem.
Speaker C: Well, that was one of the trigger points, concurrency, you've mentioned concurrency was a big deal because when you're interacting with people, the last thing you ever want to see is the thing like waiting and issues about the software development process. When faults happen, can you recover from them? What can you do to make it easier to create and eliminate complex data structures? What can you do to fix one of the most common sea problems, which is storage leaks and its evil twin, the freed but still being used piece of memory. You free something and then you keep using it.
Speaker B: Oh yeah.
Speaker C: So when I was originally thinking about that, I was thinking about that in terms of, of safety and security issues. And one of the things I sort of came to believe came to understand was that it wasn't just about safety and security, but it was about developer velocity. And I got really religious about this because at that point I had spent an ungodly amount of my life hunting down mystery pointer bugs. And, you know, like two thirds of my time as a software developer was, you know, because the mystery pointer bugs tend to be the hardest to find because they tend to be very, very statistical. The ones that hurt, you know, they're, you know, they're like a one in a million chance and, but nevertheless create.
Speaker B: An infinite amount of suffering.
Speaker C: Right. Because when you're doing a billion operations a second, you know, one in a million chance means it's gonna happen. And so I got really religious about this thing about, you know, making it so that if something fails, it fails immediately and visibly. And one of the things that was a real attraction of Java to lots of development shops was that we get our code up and running twice as fast.
Speaker B: You mean the entirety of the development process, debugging, all that kind of stuff?
Speaker C: Yeah. So if you measure time from, you know, you first touch fingers to keyboard until you get your first demo out, not much different. But if you look from fingers touching keyboard to solid piece of software that you could release in production, it would be way faster.
Speaker B: And I think what people don't often realize, there's, yeah, there's things that really slow you down. The hard to catch bugs probably is the thing that really slows down, that.
Speaker C: Really slows things down. But also one of the things that you get out of object oriented programming is a strict methodology about what are the interfaces between things and being really clear about how parts relate to each other. And what that helps with is so many times what people do is they kind of like sneak around the side. So if you've built something and people are using it, and then you say, well, okay, you know, I built this thing, you use it this way, and then you change it in such a way that it still does what you said it does. It just does it a little bit different. But then you find out that somebody out there was sneaking around the side. They had sort of tunneled in a back door, and this person, their code broke. And because they were sneaking through a side door. And normally the attitude is dummy, but a lot of times you can't get away. You can't just slap their hand and tell them to not do that because it's some bank's account reconciliation system that some developer decided, oh, I'm lazy, you know, I'll just sneak through the back door.
Speaker B: And because the language allows it, I mean, you can't even get mad at them.
Speaker C: And so one of the things I did that on the one hand upset a bunch of people is that I made it so that you really couldn't go through backdoors, right. So the whole point of that was to say if you need, you know, if the interface here isn't right. The wrong way to deal with that is to go through a back door. The right way to deal with it is to walk up to the developer of this thing and say, change the interface, fix it. So it was kind of like a social engineering thing, and it's brilliant. And people ended up discovering that that really made a difference in terms of a bunch of this stuff. If you're just screwing around, writing your own class project scale stuff, a lot of this stuff isn't quite so important because you're both sides of the interface. But when you're building larger, more complex pieces of software that have a lot of people working on them, and especially when they span organizations, you know, having really clear, having clarity about how that gets structured saves your life. Yeah. And you know, especially, you know, there's so much software that is fundamentally untestable, you know, until you do the real thing. Right.
Speaker B: It's better to write good code in the beginning as opposed to writing crappy code and then trying to fix it and trying to scramble and figure out and through testing, figure out where the bugs are.
Speaker C: Yeah, it's like which shortcut caused that rocket to not get where it was needed to go.
Speaker B: So I think one of the most beautiful ideas, philosophically and technically, is of a virtual machine, the java virtual machine. Again, apologize to romanticize things, but.
Speaker A: How.
Speaker B: Did the idea of the JVM come to be? How to you radical of an idea? It is, because it seems to me to be just a really interesting idea in the history of programming.
Speaker C: So.
Speaker B: And what is it?
Speaker C: So the Java virtual machine, you can think of it in different ways because it was carefully designed to have different ways of viewing it. So one view of it that most people don't really realize is there is that you can view it as sort of an encoding of the abstract syntax tree in reverse polish notation. I don't know if that makes any sense at all. I could explain it, and that would blow all of our time. But the other way to think of it and the way that it ends up being explained is that it's like the instruction set of an abstract machine that's designed such that you can translate that abstract machine to a physical machine. And the reason that that's important. So if you wind back to the early nineties, when we were talking to all of these companies doing consumer electronics, and you talk to the purchasing people, there were interesting conversations with purchasing. So if you look at how these devices come together, they're sheet metal and gears and circuit boards and capacitors and resistors. And stuff. And everything you buy has multiple sources. So you can buy a capacitor from here, you can buy a capacitor from there, and you've got kind of a market so that you can actually get a decent price for a capacitor. But CPU's, and particularly in the early nineties, CPU's were all different and all proprietary. So if you use the chip from intel, you had to be an intel customer for the end of. Till the end of time, because if you wrote a bunch of software, you know, when you wrote software using whatever technique you wanted. And C was particularly bad about this because there was a lot of properties of the underlying machine that came through. So you were stuck.
Speaker B: So the code you wrote, you were stuck to that particular machine, you were.
Speaker C: Stuck to that particular machine, which meant that they couldn't decide, you know, intel is screwing us. I'll start buying chips from, you know, Bob's better chips. This drove the, like, the purchasing people absolutely insane that they were welded into this decision and they would have to make this decision before the first line of software was written.
Speaker B: That's funny that you're talking about the purchasing piece. So that's one perspective, right? There's a lot of other perspectives that all probably hated this idea, right? But from a technical aspect, just like the creation of an abstraction layer that's agnostic to the underlying machine, from the perspective of the developer, I mean, that's brilliant, right?
Speaker C: Well, so that's like across the spectrum of providers of chips. But then there's also the time thing, because as you went from one generation to the next generation to the next generation, they were all different, and you would often have to rewrite your software.
Speaker B: Oh, you mean generations of machines of different kinds.
Speaker C: One of the things that sucked about a year out of my life was when San went from the Motorola 6810 processor to the 68020 processor. Then they had a number of differences, and one of them hit us really hard. And I ended up being the point guy on the worst case of where the new instruction cache architecture hurt us.
Speaker B: Well, okay, so, I mean, one of this idea. I mean, okay, so, yeah, you articulate a Yemenite really clear, fundamental problem in all of computing. But how, where do you get the guts to think we can actually solve this?
Speaker C: You know, in our conversations with, you know, all these vendors, you know, these, these problems started to show up, and I kind of had this epiphany because it reminded me of a summer job that I had had in grad school. So back in grad school, my thesis advisor well, I had two thesis advisors for bizarre reasons. One of them was a guy named Raj Reddy. The other one was Bob Sproul. And Raj. I love Raj. I love both of them. But Raj is amazing. So the department had bought a bunch of early workstations from a company called Three Rivers Computer Company. And three Rivers Computer company was a bunch of electrical engineers who wanted to do as little software as possible. So they knew that they'd need to have, like, compilers and an OS and stuff like that, and they didn't want to do any of that. And they wanted to do that for as close to zero money as possible. So what they did was they built a machine whose instruction set was the. Was literally the byte code for UCSD, pascal, the P code. And so we had a bunch of software that was written for this machine. And for various reasons, the company wasn't doing terrifically well. We had all this software on these machines, and we wanted it to run on other machines, but principally the vAx. And so Raj asked me if I could come up with a way to port all of this software from the Perc machines to vaxes. And I think he, you know, what he had in mind was something that would translate from, like, Pascal to C or Pascal to. Actually, at those times, pretty much it was, you could translate to c or c, and if you didn't like translating to sea, you could translate to. See, there was, you know, it's like the Henry Ford, you know, any color you want, just as long as it's black. And I went, that's really hard.
Speaker B: Fascinating.
Speaker C: And I noticed that. And I was, like, looking at stuff, and I went, ooh, I bet I could rewrite the p code into vax assembly code. And I. And then I started to realize that, you know, there were some properties of p code that made that really easy. Some properties that made it really hard. So I ended up writing this thing that translated from. From P code on the three rivers perks into assembly code on the vax. And I actually got higher quality code than the C compiler. And so everything just got really fast. It was really easy. It was like, wow, I thought that was a sleazy hack because I was lazy. And in actual fact, it worked really well. And I tried to convince people that that was maybe a good thesis topic, and nobody was like, nah, really?
Speaker A: That's.
Speaker B: I mean, yeah, it's kind of a brilliant idea.
Speaker A: Right.
Speaker B: Maybe you didn't have the. You weren't able to articulate the big picture of it.
Speaker C: Yeah. And I think, you know, that was a key part. But so then, you know, clock comes forward a few years, and it's like, we've got to be able to, you know, if they wanted to be able to switch from, you know, this weird microprocessor to that weird and totally different microprocessor. How do you do that? And I kind of went, oh, maybe by doing something kind of in the space of Pascal P code, I could do like multiple translators. And I spent some time thinking about that and thinking about what worked and what didn't work. When I did the, the p code to vax translator, and I talked to some of the folks who were involved in smalltalk, because smalltalk also did a byte code. And then I kind of went, yeah, I want to do that. And it had the other advantage, that you could either interpret it or compile it. And interpreters are usually easier to do, but not as fast as a compiler. So I figured, good, I can be lazy again. Sometimes I think that most of my good ideas are driven by laziness, and often I find that some of people's stupidest ideas are because they're insufficiently lazy. They just want to build something really complicated. It's like, it doesn't need to be that complicated. Yeah. And so, and so that's how that came out. And, you know, but that also turned into kind of a, you know, almost a religious position on my part, which was. Which got me in several other fights. So, like, like, one of the things that was a real difference was the way that arithmetic worked. You know, once upon a time, there were, you know, it wasn't always just two's complement arithmetic. There were some machines that had one's complement arithmetic, which was like almost anything built by CDC. And occasionally there were machines that were decimal arithmetic. And I was like, this is crazy. You know, pretty much to his complement, integer arithmetic has won. So just, let's just do that. Just do that. One of the other places where there was a lot of variability was in the way that floating point behaved, and that was causing people throughout the software industry much pain, because you couldn't do a numerical computing library that would work on CDC and then have it work on an IBM machine and work on a DEC machine. And as a part of that whole struggle, there had been this big body of work on floating point standards, and this thing emerged that came to be called IEEE 754, which is the floating point standard that pretty much has taken over the entire universe. And at the time I was doing Java, it had pretty much completed taking over the universe. There were still a few pockets of holdouts, but I was like, you know, it's important to be able to say what two plus two means.
Speaker B: Yeah.
Speaker C: And so I went that, and one of the ways that I got into fights with people was that there were a few machines that did not implement Ieee 754 correctly.
Speaker B: Well, of course, that's all short term kind of fights. I think in the long term, I think this vision is one out.
Speaker C: Yeah. And I think it's, you know, and it worked out over time. I mean, the biggest fights were with intel because they had done some strange things with rounding. They'd done some strange things with their transcendental functions, which turned into a mushroom cloud of, you know, weirdness.
Speaker B: Yeah. In the name of optimization. But I. From the perspective of the developer, that's not good.
Speaker C: Well, their issues with transcendental functions were just stupid.
Speaker B: Okay. So there's not even a trade off. That's just. Absolutely.
Speaker C: Yeah, they were, they were doing range reduction in for sine and cosine, using a slightly wrong value for PI.
Speaker B: Got it. Ten minutes. So in the interest of time, two questions. So one about Android and one about life. So, one, I mean, we could talk for many more hours. I hope eventually we might talk again. But I got to ask you about Android and the use of Java there, because it's one of the many places where Java just has a huge impact on this world. Just on your opinion, is there things that make you happy about the way Java is used in the Android world, and are there things that you wish were different?
Speaker C: I don't know how to do a short answer to that, but I have to do a short answer to that, so I'm happy that they did it. Java had been running on cell phones at that time for quite a few years, and it worked really, really well. There were things about how they did it and in particular, various ways that they kind of violated all kinds of contracts. The guy who led it, Andy Rubin, he crossed a lot of lines.
Speaker B: There's some lines crossed, yeah, lines were.
Speaker C: Crossed that have since mushroomed into giant court cases and, you know, they didn't need to do that. And in fact, it would have been so much cheaper for them to not cross lines.
Speaker B: I mean, I suppose they didn't anticipate the success of this whole endeavor, or do you think at that time it was already clear that this is going to blow up?
Speaker C: I guess I sort of came to believe that it didn't matter what. And he did. It was going to blow up.
Speaker B: Okay.
Speaker C: He's, you know, I kind of started to think of him as like a manufacturer of bombs.
Speaker B: Yeah. Some of the best things in this world come about. They're a little bit of explosive.
Speaker C: Well, and some of the worst and.
Speaker B: Some of the worst. Beautifully put. But is there? And like you said, I mean, does that make you proud that the java is in. Yeah, is in millions. I mean, it could be billions of devices and.
Speaker C: Yeah, well, I mean, it was in billions of phones before Android came along. And, you know, I'm just as proud as, you know, of the way that, like, the, the smart card standards adopted Java and they did it. They, you know, everybody involved in that did a really good job. And that's, you know, billions and billions.
Speaker B: That's crazy.
Speaker C: The sim cards, you know, the sim cards in your pocket.
Speaker B: Yeah, I mean, it's, I've been outside.
Speaker C: Of that world for a decade, so I don't know how that has evolved, but, you know, it's just been crazy.
Speaker B: So on that topic, let me ask again. There's a million technical things we could talk about, but let me ask the absurd, the old philosophical question about life. What do you hope when you look back at your life and people talk about you, write about you 500 years from now, what do you hope your legacy is?
Speaker C: People not being afraid to take a leap of faith. I mean, I've got this kind of weird history of doing weird stuff.
Speaker B: It worked out pretty damn well.
Speaker C: It worked out right. And I think some of the weirder stuff that I've done has been the coolest and some of it crashed and burned and. Yeah, you know, I think well over half of the stuff that I've done is crashed and burned, which has occasionally been really annoying, but still you kept doing it. But yeah, yeah, yeah. And, you know, there, you know, even when things crash and burn, you at least learn something from, by way of advice.
Speaker B: You know, people, developers, engineers, scientists, or just people who are young to look up to you. What advice would you give them? How to approach their life.
Speaker C: Don't be afraid of risk. It's okay to do stupid things once, maybe a couple times, you know, you get a pass on the first time or two that you do something stupid, you know, the third or fourth time. Yeah, not so much. But also, you know, I don't know why, but really early on I started to think about ethical choices in my life. And because I a big science fiction fan, I got to thinking about just about every technical decision I make in terms of how do you want, are you building Blade Runner or Star Trek?
Speaker B: Which one's better.
Speaker C: Which future would you rather live in?
Speaker B: So what's the answer to that?
Speaker C: I would sure rather live in the universe of Star Trek.
Speaker B: Star Trek. Yeah. That opens up a whole topic about AI, but that's a really interesting.
Speaker C: Yeah, yeah, yeah.
Speaker B: It's a really interesting idea. So your favorite AI system would be data from Star Trek, as my least.
Speaker C: Favorite would easily be Skynet.
Speaker B: Yeah. Beautifully put. I don't think there's a better way to end it. James, I can't say enough how much of an honor it is to meet you, to talk to you. Thanks so much for wasting your time with me today.
Speaker C: Not a waste at all.
Speaker B: Thanks, James.
Speaker C: All right, thanks.
Speaker A: Thanks for listening to this conversation with James Gosling. And thank you to our sponsors, public goods betterhelp, and express VPN. Please check out these sponsors in the description to get a discount and to support this podcast. If you enjoy this thing, subscribe on YouTube, review it with five stars on Apple Podcast, follow on Spotify, support on Patreon, or connect with me on Twitter exfriedmande. And now, let me leave you with some words from James Gosling. One of the toughest things about life is making choices. Thank you for listening and hope to see you next time.
